3:I[39275,[],""]
5:I[61343,[],""]
4:["id","voc-vach-code-thu-1-con-crawler-blockchain","d"]
0:["Eps2AlxqwJy96WWFcck2D",[[["",{"children":["(with-header)",{"children":["post",{"children":[["id","voc-vach-code-thu-1-con-crawler-blockchain","d"],{"children":["__PAGE__?{\"id\":\"voc-vach-code-thu-1-con-crawler-blockchain\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(with-header)",{"children":["post",{"children":[["id","voc-vach-code-thu-1-con-crawler-blockchain","d"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(with-header)","children","post","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/duc-huy-hoang-blog-v2/_next/static/css/844b734e2c543652.css","precedence":"next","crossOrigin":"$undefined"}]]}],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(with-header)","children","post","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},["$L6",null],null]},["$L7",null],null],[[["$","link","0",{"rel":"stylesheet","href":"/duc-huy-hoang-blog-v2/_next/static/css/3bc925507a22f6b8.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/duc-huy-hoang-blog-v2/_next/static/css/c5040041f48a7c23.css","precedence":"next","crossOrigin":"$undefined"}]],"$L8"]]]]
9:I[91704,["7699","static/chunks/8e1d74a4-b38ec690e17c551f.js","7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","5452","static/chunks/5e22fd23-9bf547384c879c16.js","9212","static/chunks/59650de3-8482f365fd4de3bd.js","9956","static/chunks/ee560e2c-ec6278e6f43142a4.js","7259","static/chunks/479ba886-4069e0dde5152f77.js","6696","static/chunks/6696-d1e77fa100a1a994.js","231","static/chunks/231-1d1dbbd9987edfd4.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","816","static/chunks/816-7034e2a5cf496cf7.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3879","static/chunks/app/(with-header)/layout-90754a5e242841d7.js"],"default"]
a:I[75472,["7699","static/chunks/8e1d74a4-b38ec690e17c551f.js","7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","5452","static/chunks/5e22fd23-9bf547384c879c16.js","9212","static/chunks/59650de3-8482f365fd4de3bd.js","9956","static/chunks/ee560e2c-ec6278e6f43142a4.js","7259","static/chunks/479ba886-4069e0dde5152f77.js","6696","static/chunks/6696-d1e77fa100a1a994.js","231","static/chunks/231-1d1dbbd9987edfd4.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","816","static/chunks/816-7034e2a5cf496cf7.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3879","static/chunks/app/(with-header)/layout-90754a5e242841d7.js"],"default"]
b:I[59003,["7699","static/chunks/8e1d74a4-b38ec690e17c551f.js","7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","5452","static/chunks/5e22fd23-9bf547384c879c16.js","1821","static/chunks/52ab8b6c-c5be704ddcdd7487.js","5957","static/chunks/30a37ab2-acd517bbf780727f.js","3665","static/chunks/f97e080b-247fec55b0ccb836.js","6051","static/chunks/795d4814-b893437f0cf691b6.js","8422","static/chunks/66ec4792-6037bec13ccf3749.js","6696","static/chunks/6696-d1e77fa100a1a994.js","231","static/chunks/231-1d1dbbd9987edfd4.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","9237","static/chunks/9237-18c4642e1f0b39b3.js","4783","static/chunks/4783-02cc936d78536f08.js","8879","static/chunks/app/(with-header)/post/%5Bid%5D/page-2890ed1636289b67.js"],"default"]
d:I[60094,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"default"]
e:I[48330,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"default"]
1b:I[16683,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"default"]
1c:I[20065,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"default"]
1d:I[86281,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"ModalHelmetWrapper"]
1e:I[231,["231","static/chunks/231-1d1dbbd9987edfd4.js","9160","static/chunks/app/not-found-f52773d3d53ffb45.js"],""]
1f:I[7056,["7240","static/chunks/53c13509-f8be993a398af0e5.js","5706","static/chunks/9c4e2130-04973567e8ffec11.js","4358","static/chunks/bc9e92e6-e07d4aab665d940f.js","5605","static/chunks/e857fbaa-8837675dae653323.js","6696","static/chunks/6696-d1e77fa100a1a994.js","1296","static/chunks/1296-72e59d0b2fdacdb2.js","8143","static/chunks/8143-65dc4adbde4cc7e0.js","4783","static/chunks/4783-02cc936d78536f08.js","317","static/chunks/317-dee75a857a68f46c.js","3185","static/chunks/app/layout-83aaac12949d22a7.js"],"default"]
6:[["$","$L9",null,{}],["$","div",null,{"className":"mt-[120px]","children":[["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(with-header)","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],["$","$La",null,{}]]}]]
c:T7ce7,"use strict";
const {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];
const {useMDXComponents: _provideComponents} = arguments[0];
function _createMdxContent(props) {
  const _components = {
    a: "a",
    code: "code",
    h2: "h2",
    h3: "h3",
    hr: "hr",
    img: "img",
    li: "li",
    p: "p",
    pre: "pre",
    ul: "ul",
    ..._provideComponents(),
    ...props.components
  }, {FullSizeImage} = _components;
  if (!FullSizeImage) _missingMdxReference("FullSizeImage", true);
  return _jsxs(_Fragment, {
    children: [_jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "blockchain-crawler/bg.jpeg",
        alt: "'tailwindBg'"
      })
    }), "\n", _jsx("p", {
      class: "mt-3 mb-3",
      children: _jsx(_components.p, {
        children: "Lần này mình sẽ giới thiệu đến các bạn về 1 con crawler event của blockchain\nmà mình tự viết . Các bạn có gì góp ý đóng góp thì cứ tự nhiên để lại comment\nnha"
      })
    }), "\n", _jsxs("div", {
      id: "blockchainCrawlerMenu",
      children: [_jsxs(_components.h2, {
        children: [_jsx(_components.a, {
          href: "#blockchainCrawlerMenu",
          children: _jsx("img", {
            src: "hashtag.svg",
            width: "20px",
            height: "20px"
          })
        }), " Mục lục"]
      }), _jsxs(_components.ul, {
        children: ["\n", _jsxs(_components.li, {
          children: [_jsx(_components.a, {
            href: "#blockchainCrawlerCore",
            children: "Core concepts"
          }), "\n", _jsxs(_components.ul, {
            children: ["\n", _jsxs(_components.li, {
              children: [_jsx(_components.a, {
                href: "#blockchainCrawlerOverview",
                children: "Tổng quan"
              }), "\n", _jsxs(_components.ul, {
                children: ["\n", _jsx(_components.li, {
                  children: _jsx(_components.a, {
                    href: "#blockchainCrawlerDb",
                    children: "Thiết kế database"
                  })
                }), "\n", _jsx(_components.li, {
                  children: _jsx(_components.a, {
                    href: "#blockchainTech",
                    children: "Công nghệ sử dụng"
                  })
                }), "\n", _jsxs(_components.li, {
                  children: [_jsx(_components.a, {
                    href: "#blockchainCrawlerBaseClass",
                    children: "Các base class trong ứng dụng"
                  }), "\n", _jsxs(_components.ul, {
                    children: ["\n", _jsx(_components.li, {
                      children: _jsx(_components.a, {
                        href: "#blockchainCrawlerIntervalWorker",
                        children: "BaseIntevalWorker"
                      })
                    }), "\n", _jsx(_components.li, {
                      children: _jsx(_components.a, {
                        href: "#blockchainCrawlerEventCrawler",
                        children: "BaseEventCrawler"
                      })
                    }), "\n", _jsx(_components.li, {
                      children: _jsx(_components.a, {
                        href: "#blockchainCrawlerProcessor",
                        children: "Processor"
                      })
                    }), "\n", _jsx(_components.li, {
                      children: _jsx(_components.a, {
                        href: "#blockchainLauncher",
                        children: "BaseLauncher"
                      })
                    }), "\n"]
                  }), "\n"]
                }), "\n"]
              }), "\n"]
            }), "\n"]
          }), "\n"]
        }), "\n", _jsx(_components.li, {
          children: _jsx(_components.a, {
            href: "#blockchainCrawlerSummary",
            children: "Tổng kết"
          })
        }), "\n"]
      }), _jsx(_components.hr, {})]
    }), "\n", _jsx("div", {
      id: "blockchainCrawlerCore",
      children: _jsxs("article", {
        id: "blockchainCrawlerOverview",
        children: [_jsxs(_components.h2, {
          children: [_jsx(_components.a, {
            href: "#blockchainCrawlerOverview",
            children: _jsx("img", {
              src: "hashtag.svg",
              width: "20px",
              height: "20px"
            })
          }), " Tổng quan"]
        }), _jsx(_components.p, {
          children: "Trước hết thì mình sẽ nói về cách hoạt động của con crawler. Nó là 1 chương trình nodejs chạy 1 worker interval để crawl theo từng block mới đc thêm vào trên 1 mạng blockchain qua đó thực hiên các action update owner của nft, list nft lên sàn, hay stop listing nft trên sàn."
        }), _jsxs("article", {
          id: "blockchainCrawlerDb",
          class: "mt-2",
          children: [_jsxs(_components.h2, {
            children: [_jsx(_components.a, {
              href: "#blockchainCrawlerDb",
              children: _jsx("img", {
                src: "hashtag.svg",
                width: "20px",
                height: "20px"
              })
            }), " Thiết kế database"]
          }), _jsx(_components.p, {
            children: "Sau đây là sơ đồ tổng quan về database của mình:"
          }), _jsxs("div", {
            class: "mt-4",
            children: [_jsx(FullSizeImage, {
              src: '/blockchain-crawler/db.png'
            }), _jsx("div", {
              class: "mt-2",
              children: _jsxs(_components.ul, {
                children: ["\n", _jsxs(_components.li, {
                  children: ["\n", _jsxs(_components.p, {
                    children: [_jsx(_components.code, {
                      children: "nft"
                    }), ": Lưu trữ nft"]
                  }), "\n"]
                }), "\n", _jsxs(_components.li, {
                  children: ["\n", _jsxs(_components.p, {
                    children: [_jsx(_components.code, {
                      children: "collection"
                    }), ": Lưu collection của nft"]
                  }), "\n"]
                }), "\n", _jsxs(_components.li, {
                  children: ["\n", _jsxs(_components.p, {
                    children: [_jsx(_components.code, {
                      children: "loans"
                    }), ": Lưu\ntrạng thái và các hành động ", _jsx(_components.code, {
                      children: "lent"
                    }), ",", _jsx(_components.code, {
                      children: "rent"
                    }), " của nft tương ứng"]
                  }), "\n"]
                }), "\n", _jsxs(_components.li, {
                  children: ["\n", _jsxs(_components.p, {
                    children: [_jsx(_components.code, {
                      children: "crawl_process"
                    }), ": Như mình đã nói trên kia ứng dụng của mình sẽ chạy interval worker để xử lý block mới trên 1 contract chỉ  vì vậy bảng này sẽ lưu lại block mới nhất mà đã được process."]
                  }), "\n"]
                }), "\n", _jsxs(_components.li, {
                  children: ["\n", _jsxs(_components.p, {
                    children: [_jsx(_components.code, {
                      children: "queue_logs"
                    }), ": Ứng dụng của mình sẽ không xử lý trực tiếp mà dùng queue pattern để xử lý data. Trước tiên push data nhận đc từ worker bất kì vào bảng queue_log kèm với queue_name tương ứng. Từ đó lấy data từ queue_log ứng và xử lý"]
                  }), "\n"]
                }), "\n"]
              })
            })]
          })]
        }), _jsxs("article", {
          id: "blockchainTech",
          children: [_jsxs(_components.h2, {
            children: [_jsx(_components.a, {
              href: "#blockchainTech",
              children: _jsx("img", {
                src: "hashtag.svg",
                width: "20px",
                height: "20px"
              })
            }), " Công nghệ sử dụng và các gói quan trọng"]
          }), _jsxs(_components.ul, {
            children: ["\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "Typescript"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "Nodejs"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "Express"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "PostgreSQL"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "Redis"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "Moralis"
              })
            }), "\n", _jsxs(_components.li, {
              children: [_jsx(_components.code, {
                children: "bull"
              }), " (gói quan trọng dùng cho Queue pattern)"]
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "web3"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "ethers"
              })
            }), "\n", _jsx(_components.li, {
              children: _jsx(_components.code, {
                children: "typeorm"
              })
            }), "\n"]
          })]
        }), _jsxs("article", {
          id: "blockchainCrawlerBaseClass",
          children: [_jsxs("section", {
            id: "blockchainCrawlerIntervalWorker",
            children: [_jsxs(_components.h2, {
              children: [_jsx(_components.a, {
                href: "#blockchainCrawlerBaseClass",
                children: _jsx("img", {
                  src: "hashtag.svg",
                  width: "20px",
                  height: "20px"
                })
              }), " Các base class trong ứng dụng"]
            }), _jsx("div", {
              class: "ml-4",
              children: _jsxs(_components.h3, {
                children: [_jsx(_components.a, {
                  href: "#blockchainCrawlerIntervalWorker",
                  children: _jsx("img", {
                    src: "hashtag.svg",
                    width: "20px",
                    height: "20px"
                  })
                }), " BaseIntevalWorker"]
              })
            }), _jsxs(_components.ul, {
              children: ["\n", _jsxs(_components.li, {
                children: [_jsx(_components.code, {
                  children: "BaseIntevalWorker"
                }), " : Một cái \"khuôn\" để thực hiện 1 action nhất định trong 1 khoảng thời gian. Phương thức ", _jsx(_components.code, {
                  children: "prepare"
                }), " và ", _jsx(_components.code, {
                  children: "doProcess"
                }), " sẽ được các lớp kế thừa lớp này viết vào thực hiện action nhất định"]
              }), "\n"]
            }), _jsx(_components.pre, {
              filename: "BaseIntevalWorker.ts",
              children: _jsx(_components.code, {
                className: "language-ts",
                children: "export abstract class BaseIntervalWorker {\n  private nextTickTime: number = 3000\n  private processingTimeout: number = 6000\n  private isStopped: boolean = false\n\n  public getProcessingTimeout() {\n    return this.processingTimeout\n  }\n\n  public getNextTickTime() {\n    return this.nextTickTime\n  }\n\n  public setNextTickTime(time: number) {\n    this.nextTickTime = time\n  }\n\n  public setProcessingTimeout(time: number) {\n    this.processingTimeout = time\n  }\n  public stop() {\n    this.isStopped = true\n  }\n\n  public start(): void {\n    this.prepare()\n      .then(() => {\n        this.onTick()\n      })\n      .catch(e => {\n        console.log(e)\n        console.log(`${this.constructor.name} prepare failed`)\n      })\n  }\n\n  private onTick() {\n    if (this.isStopped) {\n      return\n    }\n    const timer = setTimeout(() => {\n      console.log(`${this.constructor.name} time out!`)\n      process.exit(1)\n    }, this.getProcessingTimeout())\n    this.doProcess()\n      .then(() => {\n        if (this.isStopped) return\n        clearTimeout(timer)\n        setTimeout(() => {\n          this.onTick()\n        }, this.getNextTickTime())\n      })\n      .catch(e => {\n        console.log(e)\n        if (this.isStopped) return\n        clearTimeout(timer)\n        setTimeout(() => {\n          this.onTick()\n        }, this.getNextTickTime())\n      })\n  }\n\n  protected abstract prepare(): Promise<void>\n  protected abstract doProcess(): Promise<void>\n}\n"
              })
            }), _jsx("hr", {
              class: "mb-4 mt-4"
            })]
          }), _jsxs("section", {
            id: "blockchainCrawlerEventCrawler",
            children: [_jsx("div", {
              class: "ml-4",
              children: _jsxs(_components.h3, {
                children: [_jsx(_components.a, {
                  href: "#blockchainCrawlerEventCrawler",
                  children: _jsx("img", {
                    src: "hashtag.svg",
                    width: "20px",
                    height: "20px"
                  })
                }), " BaseEventCrawler"]
              })
            }), _jsxs(_components.ul, {
              children: ["\n", _jsxs(_components.li, {
                children: [_jsx(_components.code, {
                  children: "BaseEventCrawler"
                }), ": Một lớp base khác được kế thừa từ ", _jsx(_components.code, {
                  children: "BaseIntervalWorker"
                }), " chịu trách nhiệm đọc những block mới nhất từ đó truyền data đọc được qua phương thức abstract ", _jsx(_components.code, {
                  children: "handleCrawledEvents"
                }), " từ đó các lớp khác kế thừa lớp này sẽ kế thừa và tùy biến thực hiện action với data crawl được"]
              }), "\n"]
            }), _jsx(_components.pre, {
              filename: "BaseEventCrawler.ts",
              children: _jsx(_components.code, {
                className: "language-ts",
                children: "import { BaseIntervalWorker } from './BaseIntervalWorker'\nimport Web3 from 'web3'\nimport dataSource from '../../configs/dataSource'\nimport CrawlProcess from '../../entities/CrawlProcess'\nimport { Interface, JsonRpcProvider } from 'ethers'\nimport { DEFAULT_BREAK_TIME_AFTER_ONE_GO } from '../../common/constant'\nimport { NETWORK } from '../../common/enum'\nexport interface IEventCrawler {\n  networkConfigs: {\n    contract: {\n      contractName: string\n      contractAddress: string\n      contractAbi: any\n    }\n\n    rpcUrl: string\n    network: NETWORK\n    blockPerOneGo: number\n    averageBlockTime: number\n    latestFromNetwork: boolean\n    confirmationBlock: number\n    latestBlock?: number\n  }\n}\n\nabstract class BaseEventCrawler<R> extends BaseIntervalWorker {\n  private LATEST_BLOCK_FROM_NETWORK: number = NaN\n  private LATEST_PROCESSED_BLOCK: number = NaN\n  private crawlProcess: CrawlProcess\n  constructor(protected options: IEventCrawler) {\n    super()\n  }\n\n  protected abstract handleCrawledEvents(datas: Array<R>): Promise<void>\n\n  protected async processBlock({\n    fromBlock,\n    toBlock,\n    latestNetworkBlock\n  }: {\n    fromBlock: number\n    toBlock: number\n    latestNetworkBlock: number\n  }) {\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\n    const contract = new web3.eth.Contract(\n      this.getContractConfigs().contractAbi,\n      this.getContractConfigs().contractAddress\n    )\n    console.log(\n      `Begin process from ${fromBlock} to ${toBlock} / Latest network block: ${latestNetworkBlock}`\n    )\n\n    const eventLogs = await contract.getPastEvents(\n      'allEvents',\n      {\n        fromBlock,\n        toBlock\n      },\n      (err: any) => {\n        !!err && console.log('Crawl event from sc:', err)\n      }\n    )\n    // console.log(\"total crawled data:\", eventLogs);\n    const formattedEventLogs = eventLogs\n\n    await this.handleCrawledEvents(\n      formattedEventLogs\n        .sort((a, b) => a.blockNumber - b.blockNumber)\n        .map(\n          event =>\n            ({\n              event: event.event,\n              data: event.returnValues,\n              blockNumber: event.blockNumber\n            } as R)\n        )\n    )\n  }\n\n  protected getNetworkConfigs() {\n    this.getBlockData\n    return this.options.networkConfigs\n  }\n  protected getContractConfigs() {\n    return this.options.networkConfigs.contract\n  }\n  protected getCurLatestProcessedBlock() {\n    return parseInt(this.LATEST_PROCESSED_BLOCK.toString(), 10)\n  }\n\n  protected async doProcess() {\n    if (!this.crawlProcess) {\n      console.log(`No crawling process found for : ${this.constructor.name}`)\n      return\n    }\n    const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()\n\n    this.LATEST_BLOCK_FROM_NETWORK = latestBlockFromNetwork\n\n    this.LATEST_PROCESSED_BLOCK = this.crawlProcess.lastProcessedBlock\n\n    let latestProcessedBlock = this.getCurLatestProcessedBlock()\n\n    const fromBlockNumber =\n      latestProcessedBlock === 0 ? 0 : latestProcessedBlock + 1\n\n    if (fromBlockNumber > latestBlockFromNetwork) {\n      console.log(`Block ${fromBlockNumber} is the newest block`)\n      return\n    }\n\n    let toBlockNumber = fromBlockNumber + this.getNetworkConfigs().blockPerOneGo\n    if (toBlockNumber > latestBlockFromNetwork) {\n      console.log('To block is higher')\n      toBlockNumber = latestBlockFromNetwork\n    }\n\n    console.log(\n      `FROM ${fromBlockNumber} TO ${toBlockNumber} LATEST ${latestBlockFromNetwork}`\n    )\n\n    await this.processBlock({\n      fromBlock: fromBlockNumber,\n      toBlock: toBlockNumber,\n      latestNetworkBlock: latestBlockFromNetwork\n    })\n\n    const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\n    this.crawlProcess.lastProcessedBlock = toBlockNumber\n    await crawlProcessRepository.save(this.crawlProcess)\n\n    this.LATEST_PROCESSED_BLOCK = toBlockNumber\n\n    // Have processed latest network block so set next tick time by average time\n    if (fromBlockNumber === toBlockNumber) {\n      this.setNextTickTime(this.getNetworkConfigs().averageBlockTime)\n    } else {\n      this.setNextTickTime(DEFAULT_BREAK_TIME_AFTER_ONE_GO)\n    }\n  }\n\n  public async getBlockData(block_number: string | number) {\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\n    return web3.eth.getBlock(block_number)\n  }\n\n  public async getTransactionData(block_number: string | number) {\n    const jsonProvider = new JsonRpcProvider(this.getNetworkConfigs().rpcUrl)\n    const inter = new Interface(this.getContractConfigs().contractAbi)\n    const blockData = await this.getBlockData(block_number)\n\n    const datas = await Promise.all(\n      blockData.transactions.map(async transaction => {\n        const tx = await jsonProvider.getTransaction(transaction)\n        if (tx?.data) {\n          const decodedOutput = inter.parseTransaction({\n            data: tx.data,\n            value: tx.value\n          })\n          return decodedOutput\n        }\n        return null\n      })\n    )\n    return datas.filter(data => !!data)\n  }\n\n  protected async getNetworkLatestBlockNumber() {\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\n    const latestBlockFromNetwork = await web3.eth.getBlockNumber()\n    console.log(\n      'network',\n      latestBlockFromNetwork,\n      'real:',\n      latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock\n    )\n    return latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock\n  }\n\n  protected async prepare() {\n    const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\n    const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()\n\n    let crawlerProcess = await crawlProcessRepository\n      .createQueryBuilder('CrawlProcess')\n      .where({\n        contractAddress: this.getContractConfigs().contractAddress\n      })\n      .andWhere({\n        contractName: this.getContractConfigs().contractName\n      })\n      .getOne()\n\n    if (!crawlerProcess) {\n      const newCrawlProcess = new CrawlProcess()\n      newCrawlProcess.contractAddress =\n        this.getContractConfigs().contractAddress\n      newCrawlProcess.contractName = this.getContractConfigs().contractName\n      newCrawlProcess.lastProcessedBlock = this.getNetworkConfigs()\n        .latestFromNetwork\n        ? latestBlockFromNetwork === 0\n          ? 0\n          : latestBlockFromNetwork - 1\n        : (this.getNetworkConfigs().latestBlock || 0) - 1\n      try {\n        this.crawlProcess = await crawlProcessRepository.save(newCrawlProcess)\n      } catch (e: any) {\n        console.log(`Error while insert new crawling process: ${e.message}`)\n      }\n    } else {\n      const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\n      crawlerProcess.lastProcessedBlock = this.getNetworkConfigs()\n        .latestFromNetwork\n        ? latestBlockFromNetwork === 0\n          ? 0\n          : latestBlockFromNetwork - 1\n        : (this.getNetworkConfigs().latestBlock || 0) - 1\n      await crawlProcessRepository.save(crawlerProcess)\n\n      this.crawlProcess = crawlerProcess\n    }\n  }\n}\n\nexport default BaseEventCrawler\n"
              })
            }), _jsxs(_components.ul, {
              children: ["\n", _jsxs(_components.li, {
                children: ["Các configs số của lớp:", "\n", _jsxs(_components.ul, {
                  children: ["\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "contract"
                    }), ": Thông tin của contract"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "rpcUrl"
                    }), ": RPC url của mạng"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "blockPerOneGo"
                    }), ": Thông tin của contract của mạng Số lương block mà 1 lần chạy sẽ lấy (số lượng nên là ", _jsx(_components.code, {
                      children: "200"
                    }), " vì hàm ", _jsx(_components.code, {
                      children: "getPastEvents"
                    }), " của ", _jsx(_components.code, {
                      children: "web3"
                    }), " bị giới hạn số lượng trả về)"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "averageBlockTime"
                    }), " : Thời gian trung bình để mạng sinh ra 1 block mới"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "latestFromNetwork"
                    }), ": Nếu option này là ", _jsx(_components.code, {
                      children: "true"
                    }), " thì worker sẽ luôn crawl block mới nhất trên mạng và option ", _jsx(_components.code, {
                      children: "latestBlock"
                    }), " sẽ không có tác dụng"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "confirmationBlock"
                    }), ": Số lượng block mà mạng cần có để trừ đi với latest block trên mạng để chắc chắn rằng transaction trong 1 block không bị reverse"]
                  }), "\n", _jsxs(_components.li, {
                    children: [_jsx(_components.code, {
                      children: "latestBlock"
                    }), ": Số thứ tự block mà worker sẽ bắt đầu crawl (Nếu ", _jsx(_components.code, {
                      children: "latestFromNetwork"
                    }), " =  ", _jsx(_components.code, {
                      children: "true"
                    }), " thì option này không có tác dụng)"]
                  }), "\n"]
                }), "\n"]
              }), "\n"]
            }), _jsx("hr", {
              class: "mb-4 mt-4"
            })]
          }), _jsxs("section", {
            id: "blockchainCrawlerProcessor",
            children: [_jsx("div", {
              class: "ml-4",
              children: _jsxs(_components.h3, {
                children: [_jsx(_components.a, {
                  href: "#blockchainCrawlerProcessor",
                  children: _jsx("img", {
                    src: "hashtag.svg",
                    width: "20px",
                    height: "20px"
                  })
                }), " Processor"]
              })
            }), _jsxs(_components.ul, {
              children: ["\n", _jsxs(_components.li, {
                children: [_jsx(_components.code, {
                  children: "Processor"
                }), ": Như mình nói ở trên khi các crawler worker crawl được event từ block mới thì sẽ push vào bảng ", _jsx(_components.code, {
                  children: "queue_logs"
                }), " từ đó lấy data ra và xử lý. Lớp ", _jsx(_components.code, {
                  children: "Processor"
                }), " được kế thừa từ ", _jsx(_components.code, {
                  children: "BaseIntervalWorker"
                }), " sẽ làm nhiệm vụ lấy data 1 trong một khoảng thời gian. Lớp con cần kế thừa phương thức ", _jsx(_components.code, {
                  children: "handleUnfinishedOrFailedTask"
                }), " để xử lý những task được lấy từ databse."]
              }), "\n"]
            }), _jsx(_components.pre, {
              filename: "Processor.ts",
              children: _jsx(_components.code, {
                className: "language-ts",
                children: "import { Queue } from 'bull'\nimport { EntityManager } from 'typeorm'\nimport QueueManagement from '..'\nimport { QUEUE_NAMES } from '../../common/constant'\nimport { QueueStatus } from '../../common/enum'\nimport { dateInMiliseconds } from '../../common/utils'\nimport dataSource from '../../configs/dataSource'\nimport QueueLog from '../../entities/QueueLog'\nimport { BaseIntervalWorker } from '../../fetcher/base/BaseIntervalWorker'\nimport { queueLogRepository } from '../../repository'\n\ninterface IProcessor {\n  concurrency?: number\n  queue_name: string\n}\n\nabstract class Processor extends BaseIntervalWorker {\n  protected queueInstance: Queue\n  protected concurrency: number = 1\n  constructor(private queueName: QueueName) {\n    super()\n    this.queueInstance = QueueManagement.get(this.queueName)!\n  }\n\n  public setConcurrency(value: number) {\n    this.concurrency = value\n  }\n\n  public getConcurrency() {\n    return this.concurrency\n  }\n\n  protected abstract handleUnfinishedOrFailedTask(\n    manager: EntityManager,\n    listTask: Array<QueueLog>\n  ): Promise<void>\n\n  protected async doProcess(): Promise<void> {\n    dataSource.transaction(async (manager: EntityManager) => {\n      const listQueueLogs = await manager\n        .getRepository(QueueLog)\n        .createQueryBuilder('queue_logs')\n        .orderBy('retry_at', 'ASC')\n        .where(\n          'queue_name = :queue_name AND try_num < 3 AND retry_at < :now AND retry_at IS NOT NULL AND status <> :status',\n          {\n            now: dateInMiliseconds(),\n            status: QueueStatus.COMPLETE,\n            queue_name: this.queueName\n          }\n        )\n        .take(this.getConcurrency())\n        .getMany()\n\n      await this.handleUnfinishedOrFailedTask(manager, listQueueLogs)\n    })\n  }\n}\n\nexport default Processor\n"
              })
            }), _jsx("hr", {
              class: "mb-4 mt-4"
            })]
          }), _jsxs("section", {
            id: "blockchainLauncher",
            children: [_jsx("div", {
              class: "ml-4",
              children: _jsxs(_components.h3, {
                children: [_jsx(_components.a, {
                  href: "#blockchainLauncher",
                  children: _jsx("img", {
                    src: "hashtag.svg",
                    width: "20px",
                    height: "20px"
                  })
                }), " BaseLauncher"]
              })
            }), _jsxs(_components.ul, {
              children: ["\n", _jsxs(_components.li, {
                children: ["Và cuối cùng là lớp ", _jsx(_components.code, {
                  children: "BaseLauncher"
                }), " dùng để start các worker theo ý của người viết. Các lớp con cần kế thừa phương thức ", _jsx(_components.code, {
                  children: "prepare"
                }), " và ", _jsx(_components.code, {
                  children: "handleStart"
                }), " để thực hiện logic."]
              }), "\n"]
            }), _jsx(_components.pre, {
              filename: "Processor.ts",
              children: _jsx(_components.code, {
                className: "language-ts",
                children: "  import { wrapperAsync } from '../../common/utils'\n\n  export default abstract class BaseLauncher {\n    constructor() {}\n    protected abstract prepare(): Promise<void>\n    protected abstract handleStart(): Promise<void>\n    public async start() {\n      const [_, prepareError] = await wrapperAsync(this.prepare())\n      if (prepareError) {\n        console.log(`${this.constructor.name} cannot prepare`)\n        return\n      }\n\n      const [startRs, startError] = await wrapperAsync(this.handleStart())\n\n      if (startError) {\n        console.log(`${this.constructor.name} running failed`)\n        return false\n      } else {\n        console.log(`${this.constructor.name} running succeed`)\n        return true\n      }\n    }\n  }\n"
              })
            }), _jsx(_components.hr, {})]
          })]
        })]
      })
    }), "\n", _jsxs("div", {
      id: "blockchainCrawlerSummary",
      class: "mt-4",
      children: [_jsxs(_components.h2, {
        children: [_jsx(_components.a, {
          href: "#blockchainCrawlerSummary",
          children: _jsx("img", {
            src: "hashtag.svg",
            width: "20px",
            height: "20px"
          })
        }), " Tổng kết"]
      }), _jsx(_components.p, {
        children: "Như vậy là mình đã giới thiệu cho các bạn về phần 1 về 1 con crawler blockchain rồi. Hẹn các bạn phần sau để implement các lớp base mà hôm nay mình đã giới thiệu các bạn nhé"
      })]
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = {
    ..._provideComponents(),
    ...props.components
  };
  return MDXLayout ? _jsx(MDXLayout, {
    ...props,
    children: _jsx(_createMdxContent, {
      ...props
    })
  }) : _createMdxContent(props);
}
return {
  default: MDXContent
};
function _missingMdxReference(id, component) {
  throw new Error("Expected " + (component ? "component" : "object") + " `" + id + "` to be defined: you likely forgot to import, pass, or provide it.");
}
2:["$","section",null,{"className":"max-w-full xl:max-w-[1200px] px-[16px] md:px-[40px] mx-auto","children":["$","$Lb",null,{"metadata":{"slug":"voc-vach-code-thu-1-con-crawler-blockchain-phan-1","title":"Vọc vạch code thử 1 crawler event trên mạng blockchain phần 1","date":"04/04/2023","image":"blockchain-crawler/bg.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Bài viết hướng dẫn chi tiết về 1 chương trình ví dụ crawler event của blockchain","tags":["Tech","Blockchain","Backend","Nodejs","SelfTaught"],"isFeature":true,"minutesRead":20},"postDetailCompliedData":{"compiledSource":"$c","frontmatter":{},"scope":{}}}]}]
f:T12f3,
!['vs_code'](vs_code.png)

Bạn là một developer và bạn xài Visual Studio Code.
Visual Studio Code là 1 text editor khá mới nhưng free, chạy được trên nhiều hệ điều hành. Tuy chỉ là text editor nhưng ta vẫn có thể compile, run, debug code trên VS Code, không thua gì cái IDE xịn.
Vừa nhẹ, vừa free, lại mạnh mẽ, nên dân web developer như mình rất khoái dùng VS Code.
Sau đây mình sẽ giới thiệu cho các bạn những extension xịn xò

<Article id="extensionList" title="Danh sách extension">

- [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) : VSCode đã hỗ trợ pull/push từ Git, nhưng GitLens bá đạo hơn nhiều. Nó giúp bạn biết từng dòng code **do ai viết, viết vào lúc nào, nằm trong commit nào**. Bạn cũng có thể **tua ngược về quá khứ để xem file đã thay đổi như thế nào**, rất tiện

!['git_lens'](vs-code-extension-post/git_lens.png)

- [Color Highlight](https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight) : Color Highlight hỗ trợ hightlight màu ở editor của bạn.

![Color Highlight](vs-code-extension-post/color_hight_light.png)

- [vscode-icons](https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons) : Extension icon cho file trong VS code của bạn.

![vscode-icons](vs-code-extension-post/icons.png)

- [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) : Extension cho phép chúng ta biết được thư viện nào quá nặng, nên thay thế hoặc loại bỏ, hoặc import 1 phần nhỏ thôi

![Import Cost](vs-code-extension-post/import_cost.png)

- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) : Extension này sẽ highlight những đoạn sai chính tả để mình sửa nha.

![Code Spell Checker](vs-code-extension-post/code_spell_checker.png)

- [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) : Path Intellisense giúp chúng ta trong giai đoạn import các module(có thể show tên các file thậm chí cả hidden file nếu được config)

![Path Intellisense](vs-code-extension-post/path_intellisense.png)

- Cuối cùng là cặp đôi [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) và [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)

ESLint:

![ESLint](vs-code-extension-post/eslint.png)

Prettier:

## ![Prettier](vs-code-extension-post/prettier.png)

</Article>

<Article id="webExtension" title="Web extension">

Bên trên là những extension nên dùng dành cho mọi dev, nhưng mà còn web dev như mình thì sao. Mình xin giới thiệu các bạn những extension hay ho cho dân làm web

- [HTML CSS Support](https://marketplace.visualstudio.com/items?itemName=ecmel.vscode-html-css) :Làm việc với web chắc chắn không thể không biết HTML,CSS rồi. Một extension hữu ích cho web developer.

![HTML CSS Support](vs-code-extension-post/html_css_support.png)

- [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) : Một extension rất tiện để chúng ta phát triển HTML, CSS mà k cần reload lại page.

![Live Server](vs-code-extension-post/live_server.png)

- [JavaScript (ES6)](https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets) : Một extension hữu ích dành cho Javascript dev. Extension này bao gồm các snippets cho JavaScript trong cú pháp của ES6.

![JavaScript (ES6)](vs-code-extension-post/js6_snippet.png)

- [npm Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense) : Giúp cho việc tự động điền npm modules trong câu lệnh `import`.

![npm Intellisense](vs-code-extension-post/npm_intellisense.png)

- [YAML](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml) : Extension hỗ trợ cho YAML file.

![YAML](vs-code-extension-post/yaml.png)

{" "}

<Quote
  title={"Nên cài extension tùy vào mục đích của bạn !!!"}
  type={"WARNING"}
>
  Ngoài ra, tuỳ vào ngôn ngữ/framework đang dùng mà các bạn có thể cài thêm Code
  Snippets hoặc VSCode Extension cho ngôn ngữ đó. Bản thân mình code React, Vue
  nên cài thêm rất nhìu luôn á.
</Quote>

</Article>

<Article id="extensionConclusionNext" title="Kết luận">
Trong bài này , mình đã giới thiệu cho các bạn những extension bá đạo mà các bạn nên dùng rồi. Cài đủ các extension các bạn sẽ có 1 bản 
VS Code khá mạnh, đủ xài để code web nhé.

</Article>
10:T2cc2,
!['tailwindBg'](cach-dung-tailwind/tailwindBg.webp)

Chào các bạn qua bài trước chắc hẳn các bạn đã có thể cài đặt TailwindCSS
cho dự án của mình rồi nếu các bạn bỏ lỡ thì nó [ở đây](/post/cai-dat-tailwind-css).
Hôm nay chúng ta tiếp tục với việc tìm hiểu TailwindCSS qua các ví dụ.

<Article id="tailwindFunctionIndex" title="Core concepts">
<Article id="tailwindNew" title="Điểm mới khi dùng Tailwind CSS">

- Tailwind cho phép chúng ta reuse lại các class CSS có sẵn (tương tự Bootstrap)
  điểm khác biệt là Bootstrap dành cho element còn Tailwind là property. Lấy ví dụ
  Bootrap có các class như `modal`,`btn`,... các class này đã được đóng gói để trở thành
  một element hoàn chỉnh còn Tailwind của chúng ta chỉ là các thuộc tính `bg-sky-500`,`rounded`, ...

- Các class kiểu thuộc tính của Bootstrap cũng có như `position-relative`,`border`, ...
  nhưng về độ đa dạng và độ mềm dẻo thì chắc chắn không thể bằng Tailwind được.

- **Về responsive** Tailwind có thể cho chúng ta inline style được lẫn cả các
  [pseudo-classes](https://www.w3schools.com/css/css_pseudo_classes.asp),
  [pseudo-elements](https://www.w3schools.com/css/css_pseudo_elements.asp),
  [attribute selectors](https://www.w3schools.com/css/css_attribute_selectors.asp)

</Article>

<Article id="tailwindUtilities" title="Utilities trong Tailwind CSS">

<Article id="tailwindUtilityPseudoClasses" title="Pseudo classes">
- Với Pseudo classes:

<div className="mt-6"></div>

```jsx filename="App.js"
// Hover button example
<button className="rounded text-white text-center px-2 py-1 bg-sky-500 hover:bg-sky-700">Button</button>

// Input focus example

<input
  type="email"
  className="mt-3 rounded px-2 py-1 text-slate-900 border-slate-300 border outline-none focus:ring-1 focus:ring-sky-500 focus:invalid:ring-red-500 invalid:border-red-500"
  placeholder="Email only..."
/>

// Style children base on parent pseudo class. Add `group` to parent

<div aria-label="Parent" className="group bg-sky-500 hover:bg-black">
  <div aria-label="Children">
    <p className="group-hover:text-red-500">
      Hover parent to see me change color to red
    </p>
    <p className="group-hover:text-green-500">
      Hover parent to see me change color to green
    </p>
  </div>
</div>

// Style next sibling based on another sibling. Add `peer` to a previous sibling (only previous siblings can be marked as peers)

<input type={"email"} placeholder="Email only..."
className="mt-3 rounded px-2 py-1 text-slate-900 border-slate-300 border outline-none focus:ring-1 focus:ring-sky-500 focus:invalid:ring-red-500 invalid:border-red-500 peer"
/>
<p className="text-red-500 invisible peer-invalid:visible">Email invalid</p>
```

</Article>

<Article id="tailwindUtilityPseudoElements" title="Pseudo elements">
- Với Pseudo elements:

<div className="mt-6"></div>

```jsx filename="App.js"
// First letter uppercase and placeholder italic
<p className="first-letter:uppercase">hello world</p>
<input type="text" placeholder="Type here"
className="first-letter:uppercase rounded px-2 py-1 border border-sky-500 outline-none placeholder:italic"
/>

// Before and after
<label class="block">
  <span class="after:content-['*'] after:ml-0.5 after:text-red-500 block text-sm font-medium text-slate-700">
    Email
  </span>
  <input type="email" name="email" class="mt-1 px-3 py-2 bg-white border shadow-sm border-slate-300 placeholder-slate-400 focus:outline-none focus:border-sky-500 focus:ring-sky-500 block w-full rounded-md sm:text-sm focus:ring-1" placeholder="you@example.com" />
</label>
```

</Article>

<Article id="tailwindUtilityMediaQuery" title="Media queries">
- Với Media queries:<br/>
  - Có lẽ các bạn đều đã quen thuộc với [Grid system](https://getbootstrap.com/docs/4.0/layout/grid/) của 
Bootstrap với 1 class ``row`` làm parent container và các class ``col-{number}``, ``col-sm-{number}``, ...
Chúng ta có thể triển khai grid system của Boostrap bằng Tailwind và nhiều hơn thế nữa.

<div className="mt-6"></div>

```jsx filename="App.js"
// Example col grid system using Tailwind
<div className="flex h-10 flex-wrap" aria-label="Parent">
  <div className="w-2/3 sm:w-full lg:w-1/2 bg-zinc-900"></div>
  <div className="w-1/3 lg:w-1/2 bg-red-500"></div>
</div>
```

</Article>
{/* rgba(0, 0, 0, 0.68) */}

<Article id="tailwindUtilityAttributeSelector" title="Attribute selectors">
- Với attribute selectors:<br/>
  - Dưới đây là 1 ví dụ của mình với attribute selector.Trong ví dụ này mình áp dụng cả 
[``arbitrary values``](https://tailwindcss.com/docs/adding-custom-styles#using-arbitrary-values)

<div className="mt-6"></div>

```jsx filename="App.js"

// _ mean whitespace so when it compiled all children with author="Huy" attribute will
have background red
<div className="[&_[author='Huy']]:bg-red-500">
	<p author={"Huy"}>Huy</p>
</div>

// Or you can change like this to make current element background red if it had author="Huy"

<div className="[&[author='Huy']]:bg-red-500" author={"Huy"}>
	<p>Huy</p>
</div>

// Copy both of codes and run to see the difference between them ^^
```

##

</Article>

</Article>

<Article id="tailwindResponsive" title="Responsive trong Tailwind CSS">

<Article id="tailwindResponsiveDefault" title="Default break points của Tailwind CSS">
- Config breakpoints mặc định của  Tailwind

<table>
  <tr>
    <th>Prefix</th>
    <th>Minimum width</th>
    <th>CSS</th>
  </tr>
  <tr>
    <td>
      {"`"}sm{"`"}
    </td>
    <td>640px</td>
    <td>
      {"`"}@media (min-width: 640px) {"{ ... }"}
      {"`"}
    </td>
  </tr>
  <tr>
    <td>
      {"`"}md{"`"}
    </td>
    <td>768px</td>
    <td>
      {"`"}@media (min-width: 768px) {"{ ... }"}
      {"`"}
    </td>
  </tr>
  <tr>
    <td>
      {"`"}lg{"`"}
    </td>
    <td>1024px</td>
    <td>
      {"`"}@media (min-width: 1024px) {"{ ... }"}
      {"`"}
    </td>
  </tr>
  <tr>
    <td>
      {"`"}xl{"`"}
    </td>
    <td>1280px</td>
    <td>
      {"`"}@media (min-width: 1280px) {"{ ... }"}
      {"`"}
    </td>
  </tr>
  <tr>
    <td>
      {"`"}2xl{"`"}
    </td>
    <td>1536px</td>
    <td>
      {"`"}@media (min-width: 1536px) {"{ ... }"}
      {"`"}
    </td>
  </tr>
</table>

<div className="mt-3 mb-3">
  Để dùng các breakpoint cùng với style chỉ định chúng ta dùng cú pháp:
</div>

```jsx filename="App.js"
// Breakpoints from above corresponding with style class
<div class="w-16 md:w-32 lg:w-48 h-6 bg-slate-800"></div>
```

<div className="mt-3 mb-3">
  Tailwind CSS responsive sử dụng ``mobile first breakpoint system`` giống như
  Bootrap.
</div>

```jsx filename="App.js"
// Don't use sm: to target mobile devices because only on screens 640px or wider, not on smaller screen
<div className="sm:w-1/2"></div>

// Tailwind breakpoints only include a min-width and don’t include a max-width
// So we just need targeting a single breakpoint if screen width is not wider than md so div's width 100%
<div className="w-full md:w-1/2 h-6 bg-slate-800"></div>
```

</Article>

<Article id="tailwindResponsiveCustomizingConfig" title="Điều chỉnh breakpoints Tailwind CSS">
## [<img src="hashtag.svg" width="20px" height="20px"/>](#tailwindResponsiveCustomizingConfig) Responsive trong Tailwind CSS

- Custom lại breakpoints của Tailwind

```js filename="tailwind.config.js"
/** @type {import('tailwindcss').Config} */
const defaultTheme = require("tailwindcss/defaultTheme");

module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}"],
  theme: {
    extend: {
      screens: {
        tablet: "640px",
        // => @media (min-width: 640px) { ... }

        laptop: "1024px",
        // => @media (min-width: 1024px) { ... }

        desktop: "1280px",
        // => @media (min-width: 1280px) { ... }
      },
    },
  },
  screens: {
    ...defaultTheme.screens,
    sm: "576px",
    // => @media (min-width: 576px) { ... }

    md: "960px",
    // => @media (min-width: 960px) { ... }

    lg: "1440px",
    // => @media (min-width: 1440px) { ... }
  },
  plugins: [],
};
```

<Quote title={"Về cú pháp"} type={"INFO"}>
  - Ở đây chúng ta có thêm breakpoint vào ``theme`` trong ``extend`` những key:
  ``tablet``, ``laptop``, ``desktop``. - Và overwrite các breakpoints có sẵn của
  Tailwind.
</Quote>

</Article>

</Article>

<Article id="tailwindDarkMode" title="Dark Mode">

Tiếp theo là một tính năng mà rất nhiều website đã triển khai, đó là
`Dark Mode`. Tailwind đã bao gồm thuộc tính `dark` cái mà sẽ giúp
chúng ta style lại website khi mà dark mode được kích hoạt.

<br />
Trước hết chung ta thêm config vào file ``tailwind.config.js``

```js filename="tailwind.config.js"
module.exports = {
  darkMode: "class",
  // ...
};
```

<div className="mt-3 mb-3">
Sau đây là 1 ví dụ nhỏ về cách tích hợp ``Dark Mode`` của Tailwind
</div>
```jsx filename="App.jsx" showLine={true}
import React, { useEffect, useState } from "react";
export const App = () => {
  // I'm using a state because sometime you want to update dark mode based on
  // something like local storage maybe
  const [isDarkMode, setIsDarkMode] = useState(false);
  useEffect(() => {
    let htmlElement = document.documentElement;
    if (isDarkMode && htmlElement) {
      htmlElement.classList.add("dark");
    } else {
      htmlElement.classList.remove("dark");
    }
  }, [isDarkMode]);

const handleChangeMode = () => {
setIsDarkMode((prev) => !prev);
};
return (

<>
  <section className="w-screen h-screen flex items-center justify-center bg-slate-300 dark:bg-gray-900">
    <button
      className="p-2 border border-solid border-gray-900 rounded focus:border-sky-500 focus:ring-1 bg-sky-300"
      onClick={handleChangeMode}
    >
      Change mode
    </button>
  </section>
</>
); };

````
</Article>

<Article id="tailwindReusingStyles" title="Tái sử dụng style">

Bootstrap có các class với style có thể hiểu được dưới dạng elements.Chúng ta hoàn toàn có thể
thực hiện ý tưởng đó với Tailwind.

```jsx filename="App.jsx"
<button class="btn-primary">
  Save changes
</button>
````

<div className="mt-3 mb-3">Và file CSS</div>

```css filename="index.css"
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .btn-primary {
    @apply py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75;
  }
}
```

<Quote title={"Lưu ý"} type={"WARNING"}>
Bất kể bạn làm gì, đừng dùng ``@apply`` chỉ để làm mọi thứ {'"'}cleaner{'"'} vì:

- Bạn cần phải nghĩ tên class cho style mới.
- Bạn cần phải nhảy qua nhảy lại giữa các file.
- Tạo style mới dễ phá vỡ các style khác vì CSS là `global`
- Gói CSS bundle sẽ lớn hơn yepp

</Quote>

</Article>

<Article id="tailwindConclusionNext" title='Tổng kết'>
Với phần 1 này mình đã giới thiệu cho các bạn cú pháp đơn giản của TailwindCSS rồi.
Hãy tiếp tục với phần 2 về các function và nhiều thứ nâng cao hơn [ở đây]() nhé

</Article>

</Article>
11:Tb4c,
!['tailwindBg'](blockchain-crawler/bg.jpeg)

Bạn đang lo lắng vì đặt tên class, sợ bị trùng css không mong muốn,hay đang muốn một framework giống bootstrap
để tận dụng được các class dùng chung mà không viết lại quá nhiều. TailwindCSS là framework dành cho bạn

<Article id="whyTailwind" title="Tại sao lại dùng Tailwind">

- Tailwind css là một utility-first CSS framework nó hỗ trợ phát triển xây dựng nhanh chóng giao diện người dùng, nó cũng có điểm chung giống như Bootstrap &
  điểm làm nó nổi bật hơn cả đó là chúng ta có thể tùy biến phát triển css theo cách mà chúng ta định nghĩa ra.
- Hoặc là chúng ta có thể thêm các class của tailwind vào 1 class để dùng chung sau này

</Article>

<Article id="tailwindSetup" title="Cài đặt Tailwind">

Sau đây mình sẽ giới thiệu cho các bạn cách cài đặt Tailwind trong Reactjs nhé.
Chúng ta dùng [`Create React App`](https://create-react-app.dev/) nhé

- Đầu tiên các bạn tạo 1 dự án React:

```bash filename="newReactApp.sh" className="my-4"
// Init project của chúng ta
npx create-react-app react-with-tailwind
cd react-with-tailwind
```

- Tiếp theo chúng ta cài các dependency cần thiết:

```bash filename="installDependency.sh" className="my-4"
npm install -D tailwindcss postcss autoprefixer
// Sau đó init tailwind CSS trong project của chúng ta
npx tailwindcss init -p
```

- Okay chúng ta vào file tailwind.config.js vừa tạo và config như sau:

```js filename="tailwind.config.js" showLine={false} className="my-4"
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

- Và thêm `@tailwind` directives vào file index.css của bạn:

```css filename="index.css" className="my-4"
@tailwind base;
@tailwind components;
@tailwind utilities;
```

<Quote title={"Chú ý"} type={"WARNING"}>
Kiểm tra ``package.json`` của bạn nếu ``react-scripts`` >= 5 thì có thể chạy ok <br/>
Còn nếu  ``package.json`` của bạn nếu ``react-scripts`` < 5 thì bạn cần phải config thêm craco:
[``Ở đây``](https://www.npmjs.com/package/@craco/craco)
</Quote>

- Cuối cùng là thử chạy nào:

```js filename="App.js" className="mt-4"
export default function App() {
  return <h1 className="text-3xl font-bold underline">Hello world!</h1>;
}
```

</Article>

<Article id="tailwindConclusionNext" title="Kết luận">

Vậy là mình đã giới thiệu qua cho các bạn cách cài đặt TailwindCSS với React rùi.Hãy tiếp tục đến với
[bài tiếp theo](/post/cach-dung-tailwind-css-phan-1) của mình để biết được các cú pháp lẫn tiện ích
của Tailwind nha.

</Article>
12:T3225,
On a beautiful day, I received an attractive ,wonderful, interesing ideal from nowhere 😅.
So yeah, I want to share my coding knowledges to everyone whose are reading this blog. You know , sharing knowledges
to other people is an another way to learn. Knowledges in the world are unlimited. When you are reading my post and yeah when you found
something wrong or something that is unreasonable, don't hesitate leave me a comment below the post 👇 I'm would be very thankful if you would do it for me that 🤗.

- I will share all my blog's using technologies in this post. So let dive right to it.

<div className="mt-4"></div>

!['bg'](/how-i-build-this-blog/main.jpeg)

<Article id="technologies" title="Technologies">

I'm a frontend developer, right ? So I will use some modern FE's framework for my blog. The important thing is my blog will be only
integrated with `Firebase` service. I don't use any other backend service for my blog.

<div className="mt-4"></div>
!['dependencies'](/how-i-build-this-blog/dependencies.png)

<Article id="technologiesNextjs" title="Nexjs">
  My blog is using Nextjs 14. Nextjs 14 has some strong functionalies like
  `Serve actions`, `Middleware`,... But unfortunately, I'm only using `CSR`. So
  my blog will be built into static site (only html). After that i will use
  static build folder to deploy into `Github`

<div className="mt-4"></div>

!['nextjs'](/how-i-build-this-blog/nextjs.png)

</Article>

<Article id="technologiesTailwind" title="TailwindCSS">
Honestly I'm not a fan of TailwindCSS 😆. Because I think it's not fit for me.
I don't really like too long className, it will only make other coder hard to follow especially animation.
But you know Tailwind is a `CSS framework`, it's don't affect too much in logic, deploy,... And beside of that
my blog is my coding playground, I want to use another new technologies which I've never used before.

<div className="mt-4"></div>

!['nextjs'](/cach-dung-tailwind/tailwindBg.webp)

</Article>

<Article id="technologiesGrayMatter" title="gray-matter">
So we have solved the post's content problem, but how about post's metadata ? As you can see in `Home` page,
each post have description, date created,... .Besides of that when you see at the top of any `.mdx` file there is a section start and end with `---` .
That is post's metadata

<div className="my-4">
```mdx filename="how-i-build-this-blog.mdx"
---
slug: how-i-build-this-blog
title: How I build this blog
date: 07-07-2024
image: how-i-build-this-blog/main.jpeg
author: { name: Đức Huy Hoàng, avatar: avatar.jpg }
description: I want to share my personal's blog coding journey. How was it made. What kind of technology I'm using
tags: [Tech, Javascript, Frontend, Tailwind CSS]
isFeature: true
minutesRead: 15
---
```
</div>

So I'll write a function to extract post's raw content using `gray-matter` and just Nodejs `fs` module.

<div className="mt-4"></div>

```ts filename="index.ts"
import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { PostExtract, PostMetaData } from "@/types/post";

export const getMDXPostsDataAndMetaData = async (
  dir: string
): Promise<PostExtract[]> => {
  const postFileNames = await fs.readdirSync(dir);

  return postFileNames.map((fileName) => {
    const fileContent = matter(
      fs.readFileSync(path.join(dir.split("/").join("/"), fileName))
    );
    const metadata = matter(fileContent).data;

    return {
      id: fileName.split(".mdx")[0],
      metadata: metadata as PostMetaData,
      content: fileContent?.content,
    };
  });
};
```

<div className="mb-4"></div>

</Article>

<Article id="technologiesMdx" title="MDX">
Here is it, the star of the show belongs to `MDX`. I used this Markdown to write post ( you can read more of it from [`here`](https://mdxjs.com/) ).
As you can see, on the left of each section's title have a [`Chain icon`](#MDX). That is the magic of MDX, it can dip React's component inside MDX file, all
of the think you need is to pass the components you wish to `MDXRemote` component. Below is the implementation of Article's component 👇.

<div className="mt-4"></div>

```tsx filename="Article.tsx"
import Typography from "@/components/Typography";
import Link from "next/link";
import { FaLink } from "react-icons/fa";
import { twMerge } from "tailwind-merge";

interface IArticleProps
  extends React.DetailedHTMLProps<
    React.HTMLAttributes<HTMLElement>,
    HTMLElement
  > {
  id: string;
  title?: string;
  children: React.ReactNode;
}

interface IArticleTitle {
  id: string;
  title: string;
}

const ArticleTitle = ({ id, title }: IArticleTitle) => {
  return (
    <div className="flex items-center mb-2" title={title}>
      <Typography component="h5" className="text-[1.72rem] font-bold">
        <Link href={`#${id}`}>
          <FaLink
            size={"18px"}
            className="inline mr-2 dark:text-secondary-dark text-secondary rotate-[10deg] transition-all duration-500"
          />
        </Link>

        {title}
      </Typography>
    </div>
  );
};

const Article = ({
  title,
  id,
  children,
  className,
  ...rest
}: IArticleProps) => {
  const isSectionHaveTitle = !!title;
  return (
    <>
      <article
        title={title}
        id={id}
        className={twMerge("scroll-mt-[80px] my-4", className)}
        style={{
          scrollMarginTop: "80px",
        }}
      >
        {isSectionHaveTitle && <ArticleTitle id={id} title={title} />}

        {children}
      </article>
    </>
  );
};

export default Article;
```

<div className="mt-4">
  We import `Article` component and use it like this in `MDXRemote` component

  <div className="mt-4">
```tsx filename="MDXDetail.tsx"
  "use client";
import { MDXRemote, MDXRemoteProps } from "next-mdx-remote";
import Quote from "@/components/Quote";
import Typography from "../Typography";
import Article from "./Article";
import FullSizeImage from "@/components/FullSizeImage";
import CodeTag from "./Code";
import CodeBlock from "../CodeBlock";
import Divider from "../Divider";
import Img from "../Img";

import "./style.css";

export interface MDXDetailProps extends MDXRemoteProps {}

const components = {
p: Typography,
FullSizeImage: FullSizeImage,
Article: Article,
code: CodeTag,
pre: CodeBlock,
li: (props: any) => <Typography component="li" {...props} />,
hr: Divider,
img: Img,
Quote: Quote,
};

const MDXDetail = (props: MDXDetailProps) => {
return (

<MDXRemote {...props} components={components as any} />
);
};

export default MDXDetail;
````
</div>
</div>

<div className="mt-4"></div>- And implement like this in MDX file ➡️ will be complied
to what you are seeing
<div className="mb-4"></div>

```mdx filename="how-i-build-this-blog.mdx"
['nextjs'](/how-i-build-this-blog/mdx-remote.png)

<Article id="technologiesMdx" title="MDX">
  Here is it, the star of the show. I used this Markdown's library to write post
  ( you can read more it from [`MDX`](https://mdxjs.com/) ). As you can see, on
  the left of each section's title have a [`Chain icon`](#MDX). That is the
  magic of MDX, it can dip React's component inside MDX file, all of the think
  you need is to pass the components you wish to `MDXRemote` component.
</Article>
```

<div className="mb-4"></div>

In order to generate all post's router I use will Nextjs [`Generating Static Params`]("https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params") technique.

In older version of Nextjs exacly before Nextjs 13.2 if we need to generateStaticPage you'll need to use 2 functions
[`getStaticProps`]('https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props')
and
[`getStaticPaths`]('https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-paths') together.
But right now Nextjs14 have a shorten generate static page function called [`generateStaticParams`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params).
I'll use previous `getMDXPostsDataAndMetaData` combination with `generateStaticParams` and `getMDXPostsDataAndMetaData`. You can check this 👇

<div className="mt-4"></div>

```tsx filename="post/[id]/page.tsx"
import Container from "@/components/Container";
import { getMDXPostsDataAndMetaData } from "@/utils";
import fs from "fs";
import matter from "gray-matter";
import path from "path";
import { serialize } from "next-mdx-remote/serialize";
import rehypeMdxCodeProps from "rehype-mdx-code-props";
import { PostMetaData } from "@/types/post";
import PostDetailPage from "@/pages/PostDetail";
import remarkDirectives from "remark-directive";

const MDX_POST_DIR = path.join(process.cwd(), "src/posts");

export async function generateStaticParams() {
  const datas = await getMDXPostsDataAndMetaData(MDX_POST_DIR);

  return datas.map((data) => ({
    id: data.id,
    slug: data.id,
  }));
}

const PostDetail = async ({ params }: any) => {
  const fileContent = matter(
    fs.readFileSync(path.join(MDX_POST_DIR, `${params.id}.mdx`))
  );

  const metadatas: PostMetaData = matter(fileContent).data as PostMetaData;

  const serializedDatas = await serialize(fileContent.content, {
    mdxOptions: {
      remarkPlugins: [remarkDirectives],
      rehypePlugins: [rehypeMdxCodeProps],
    },
  });

  return (
    <>
      <Container>
        <PostDetailPage
          metadata={metadatas}
          postDetailCompliedData={serializedDatas}
        />
      </Container>
    </>
  );
};

export default PostDetail;
```

<div className="mt-4"></div>- `rehypeMdxCodeProps` : Plugins support for Markdown's
codeblock. I can add more properties to it like `filename`,`showLine`

</Article>

<Article id="technologiesLunr" title="Lunr">
I use [`Lunr`]("https://lunrjs.com/guides/getting_started.html") for search's engine. Remember our extracted's post data above ?
Lunr support search with score so I will order score by field like this.
<div className="mt-4"></div>

```tsx filename="SearchBackDrop.tsx"
const index = useMemo(() => {
  return lunr(function (this) {
    this.field("tags", {
      boost: 4,
      extractor: (doc: any) => {
        return doc.metadata.tags;
      },
    });
    this.field("title", {
      boost: 3,
      extractor: (doc: any) => {
        return doc.metadata.title;
      },
    });
    this.field("description", {
      boost: 2,
      extractor: (doc: any) => {
        return doc.metadata.description;
      },
    });

    this.field("content");
    this.field("author", {
      extractor: (doc: any) => {
        return doc.metadata?.author?.name;
      },
    });
    this.ref("id");
    posts.forEach((post) => {
      this.add(post);
    });
  });
}, [posts]);

// Use Lunr's index like this
const searchResultsIds = index
  .search(`*${searchK}*`)
  .map((result) => result.ref);

// Set matched posts
setFilterPosts(posts.filter((post) => searchResultsIds.includes(post.id)));
```

<div className="mb-4"></div>

So the ideal is: I will pass all posts to a `React's Context` and use it in other component.
I know this have a very big drawback like if my page grow bigger, have more posts ➡️ the datas will be very big, we'll have
some posts that we don't really need. But like I have said, we don't have any backend service except `firebase` right ? So I will
migrate it later in other version. Right now please be happy with it 😂

</Article>

<Article id="technologiesFramer" title="Framer Motion">
I use [`Framer Motion`](https://www.framer.com/motion/) for animation.Why i choose it ? 
 Because it's a great library with a simple, short syntax. Easy to read and maintain, animation between two components was 
handled very `magic`

<div className="my-4">!['bg'](/how-i-build-this-blog/framer-motion.webp)</div>

</Article>

<Article id="technologiesFirebase" title="Firebase">
I use some `Firebase` services in my website, such as [`Firebase Auth`](https://firebase.google.com/docs/auth), [`Firestore Datebase`](https://firebase.google.com/docs/firestore)
- `Firebase Auth` : Will be used for authentication ( Sign in with Google, Facebook,... )
- `Firestore Datebase` : I used it for post's comments function
But you know `Firebase` is not only having those services. It's have a lots of another services for you to explore, like [`Cloud Storage`](https://firebase.google.com/docs/storage)

<div className="my-4">!['bg'](/how-i-build-this-blog/firebase.png)</div>

</Article>

</Article>

<Article id="hibtbConclusion" title="Conclusion">
  Well, that it's all folks. This is my personal blog technology's journey. In
  the future, I will try to write more technical posts to share my knowledge to
  anyone who know the existence of this blog 😂 By the way, thank you for
  reading! See you in another interesting technical posts
</Article>
13:T2af9,
Hello guys, I would like to share you some functions which I have collected when
I was working with Javascript. I hope it can serve you well.

<Article id="utilityAsync" title="Asynchorous">
- Handle promise result

```ts filename="wrapper-async.ts" className="my-3"
export const wrapperAsync = async (pro: Promise<any>) => {
  try {
    const rs = await pro;
    return [rs, null];
  } catch (e) {
    return [null, e];
  }
};
```

- Debounce

```ts filename="debounce.ts" className="my-3"
export const debounce = (callback: Function, wait = 1000) => {
  let timeoutId: any = null;
  const func = (...args: any) => {
    window.clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => {
      callback(...args);
    }, wait);
  };
  func.clear = () => {
    window.clearTimeout(timeoutId);
  };
  return func;
};
```

- Throttle

```ts filename="throttle.ts" className="my-3"
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number = 1,
  timeout: number = 1000
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout | null = null;
  let ranCount = 0;

  return (...args: Parameters<T>) => {
    if (ranCount < limit) {
      func(...args);
      ranCount++;
    }
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        ranCount = 0;
        timeoutId = null;
      }, timeout);
    }
  };
}
```

</Article>

<Article id="utilityIsSmt" title="Is Something ?">
- Is Something ?

```ts filename="is-smt.ts" className="my-3"
const toString = Object.prototype.toString;

export function getTag(value: any) {
  if (value == null) {
    return value === undefined ? "[object Undefined]" : "[object Null]";
  }
  return toString.call(value);
}

export function isObjectLike(value: any) {
  return typeof value === "object" && value !== null;
}

export function isObject(value: any) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function");
}

export function isNull(value: any) {
  return value == null;
}

export function isNil(value: any) {
  return value == null || value === undefined;
}

export function isNumber(value: any) {
  return (
    typeof value === "number" ||
    (isObjectLike(value) && getTag(value) === "[object Number]")
  );
}

export function isBoolean(value: any) {
  return (
    value === true ||
    value === false ||
    (isObjectLike(value) && getTag(value) === "[object Boolean]")
  );
}

export function isString(value: any /*  */) {
  const type = typeof value;
  return (
    type === "string" ||
    (type === "object" &&
      value != null &&
      !Array.isArray(value) &&
      getTag(value) === "[object String]")
  );
}
```

</Article>

<Article id="utilityValidator" title="Validator">
- Email validator

```ts filename="email-validator" className="my-3"
export function validateEmail(email: string) {
  const re =
    /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(String(email).toLowerCase());
}

// Validate unicode email
export function validateEmailUnicode(email: string) {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(String(email).toLowerCase());
}
```

</Article>

<Article id="utilityDetector" title="Detector">
  - Mobile checker

```ts filename="mobile-checker.ts" className="my-3"
export const mobileCheck = function () {
  let mobileCheck = false;
  (function (a) {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
        a
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
        a.substr(0, 4)
      )
    )
      mobileCheck = true;
  })(navigator.userAgent || navigator.vendor || (window as any).opera);
  return mobileCheck;
};

export function detectMobileV2() {
  if (
    navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  ) {
    return true;
  } else {
    return false;
  }
}
```

</Article>

<Article id="utilityBlockchain" title="Blockchain">
- Replace IPFS
```ts filename="mobile-checker.ts" className="my-3"
export const replaceImageIpfs = (image: string) => {
  if (!image) {
    return "/nftDefault.png";
  } else if (image?.includes("ipfs://ipfs/")) {
    return image?.replace("ipfs://ipfs/", "https://ipfs.io/ipfs/");
  } else if (image?.includes("ipfs://")) {
    return image?.replace("ipfs://", "https://ipfs.io/ipfs/");
  } else {
    return image;
  }
};
```
- Pack and unpack price

```ts filename="price.ts" className="my-3"
export const packPrice = (price: number): string => {
  if (price > 9999.9999) throw new Error("too high");

  const stringVersion = price.toString();
  const parts = stringVersion.split(".");
  let res: string;

  if (parts.length == 2) {
    const whole = parts[0];
    let decimal = parts[1];
    while (decimal.length < 4) {
      decimal += "0";
    }
    const wholeHex = decimalToPaddedHexString(Number(whole), 16);
    const decimalHex = decimalToPaddedHexString(Number(decimal), 16);
    const hexRepr = wholeHex.concat(decimalHex.slice(2));
    res = hexRepr;
  } else {
    if (parts.length != 1) throw new Error("price packing issue");
    const whole = parts[0];
    const wholeHex = decimalToPaddedHexString(Number(whole), 16);
    const decimalHex = "0000";
    res = wholeHex.concat(decimalHex);
  }
  return res;
};

export function unpackPrice(_price: string) {
  const _scale = 1;
  let paddedString = _price.slice(2);
  let whole = converter.hexToDec(paddedString.slice(0, 4));
  let decimal = converter.hexToDec(paddedString.slice(4));

  if (whole > 9999) {
    whole = 9999;
  }
  if (decimal > 9999) {
    decimal = 9999;
  }

  let w = whole * _scale;
  let d = (decimal * _scale) / 10000;
  let price = w + d;

  return price;
}
```

</Article>

<Article id="utilityFormat" title="Format">

- Abbreviate number

```ts filename="abbreviate-number.ts" className="my-3"
export const abbreviateNumber = (number: number | string, digits = 3) => {
  number = Number(number) || 0;
  if (number === 0 || !number) return 0;

  if (number < 0.001) return "< 0.001";

  if (number < 1) {
    return parseFloat(number.toFixed(3));
  }

  const si_suffixes = [
    { value: 1, symbol: "" },
    { value: 1e3, symbol: "K" },
    { value: 1e6, symbol: "M" },
    { value: 1e9, symbol: "B" },
    { value: 1e12, symbol: "T" },
  ];

  var item = si_suffixes
    .slice()
    .reverse()
    .find(function (item) {
      return number >= item.value;
    });
  return item
    ? (number / item.value)
        .toFixed(digits)
        .replace(/(\d)(?=(\d{3})+\.)/g, "$1,")
        .replace(/^0+(?!\.)|(?:\.|(\..*?))0+$/gm, "$1") + item.symbol
    : 0;
};
```

- Remove Vietnamese

```ts filename="remove-vietnamese.ts" className="my-3"
export function removeVietnameseTones(str: string) {
  str = str.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a");
  str = str.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e");
  str = str.replace(/ì|í|ị|ỉ|ĩ/g, "i");
  str = str.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o");
  str = str.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u");
  str = str.replace(/ỳ|ý|ỵ|ỷ|ỹ/g, "y");
  str = str.replace(/đ/g, "d");
  str = str.replace(/À|Á|Ạ|Ả|Ã|Â|Ầ|Ấ|Ậ|Ẩ|Ẫ|Ă|Ằ|Ắ|Ặ|Ẳ|Ẵ/g, "A");
  str = str.replace(/È|É|Ẹ|Ẻ|Ẽ|Ê|Ề|Ế|Ệ|Ể|Ễ/g, "E");
  str = str.replace(/Ì|Í|Ị|Ỉ|Ĩ/g, "I");
  str = str.replace(/Ò|Ó|Ọ|Ỏ|Õ|Ô|Ồ|Ố|Ộ|Ổ|Ỗ|Ơ|Ờ|Ớ|Ợ|Ở|Ỡ/g, "O");
  str = str.replace(/Ù|Ú|Ụ|Ủ|Ũ|Ư|Ừ|Ứ|Ự|Ử|Ữ/g, "U");
  str = str.replace(/Ỳ|Ý|Ỵ|Ỷ|Ỹ/g, "Y");
  str = str.replace(/Đ/g, "D");
  return str;
}
```

</Article>

<Article id="utilityArray" title="Array">
Remove an item

```ts filename="array.ts" className="my-4"
export function removeItem<T>(arr: Array<T>, value: T): Array<T> {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
  }
  return arr;
}
```

Shuffle array

```ts filename="array.ts" className="my-4"
export function shuffle<T>(array: Array<T>): Array<T> {
  let currentIndex = array.length,
    randomIndex;

  // While there remain elements to shuffle.
  while (currentIndex != 0) {
    // Pick a remaining element.
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex],
      array[currentIndex],
    ];
  }

  return array;
}
```

</Article>

<Article id="utilityGenerator" title="Generator">
- UUID

```ts filename="uuid.ts" className="my-3"
// UUID v4
export function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
      v = c == "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}
```

</Article>
14:T1162,
Hello folks, today I would like to introduce to you a design pattern : `Strategy Pattern`
Imaging you are doing a choosing transport service for a food app, a delivery app or any app that need to choose transportation.
So how do you do it ? If we don't do it well ,afterwards client need to add another transportation to our app , so the transfort logic will be bigger.
It's not what we want, and also we are not talking about extensibility of our application.
So `Strategy Pattern` will be our savior.

<div className="my-4">!['strategy'](/design-patterns/strategy.webp)</div>

<Article id="strategyUML" title="UML">

<div className="my-4">!['vs_code'](design-patterns/strategy-uml.png)</div>

- Interface `Strategy` is our mold for any concrete class which implements it. Focus on the `execute` method , this function will be use
  to execute our main action. You can change this interface by using a `Abstract Class`.
- `ConcreteStrategyA`,`ConcreteStrategyB`,... or anything else whose implements interface `Strategy` need to define fully interface's properties and methods
- `Context` is where our code to be executed

{/* So let dive directly to our example: a Transportation selector function */}

</Article>

<Article id="strategyExampleDiagram" title="Sample Diagram">
<div className="my-4">
!['vs_code'](design-patterns/strategy-example-diagram.png)
</div>

- Interface `TravelStrategy` is `Strategy` base interface
- `PlaneStrategy`,`CarStrategy`,`MotorbikeStrategy` are `Concrete Class`
- `TransportContext` is `Context`

</Article>

<Article id="strategyExampleImpletation" title="Sample Implementation">
Here is the implementation of above diagram
<div className="mt-4"></div>

```ts filename="strategy-example.ts"
interface Address {
  name: string;
  location: string;
}

abstract class TravelStrategy {
  public abstract doTransport(address: Address): any;
  constructor(protected name: string) {}

  public getName() {
    return this.name;
  }
}

class CarStrategy extends TravelStrategy {
  constructor(private carName: string) {
    super("car");
  }
  public doTransport(address: Address) {
    console.log(`Go to ${address.name} by ${this.carName}`);
  }
}

class MotorbikeStrategy extends TravelStrategy {
  constructor(private motorbikeName: string) {
    super("motorbike");
  }
  public doTransport(address: Address) {
    console.log(`Go to ${address.name} by ${this.motorbikeName}`);
  }
}

class PlaneStrategy extends TravelStrategy {
  constructor(private planeName: string, private type: string) {
    super("plane");
  }
  public doTransport(address: Address) {
    console.log(
      `Go to ${address.name} by ${this.planeName} with ticket type ${this.type}`
    );
  }
}

class TransportContext {
  private travelStrategiesMap: Map<string, TravelStrategy> = new Map();
  constructor() {}
  public addStrategy(strategy: TravelStrategy) {
    this.travelStrategiesMap.set(strategy.getName(), strategy);
  }

  public executeTransport(name: string, address: Address) {
    const selectingStrategy = this.travelStrategiesMap.get(name);
    if (selectingStrategy) {
      selectingStrategy.doTransport(address);
    }
  }
}

const holidayAddress: Address = {
  location: "xxxx",
  name: "Nha Trang",
};

const carTravel = new CarStrategy("Limousine");
const planeTravel = new PlaneStrategy("Boeing", "Merchant");

const motorbikeTravel = new MotorbikeStrategy("Wave");

const transporation = new TransportContext();

transporation.addStrategy(carTravel);
transporation.addStrategy(planeTravel);
transporation.addStrategy(motorbikeTravel);

transporation.executeTransport("car", holidayAddress);
transporation.executeTransport("plane", holidayAddress);
transporation.executeTransport("motorbike", holidayAddress);
```

<div className="mb-4"></div>
As you can see, my code is so simple ^^. In real project, we need to implement a
bunch of logics inside each `doTransport` method. So be patient, you'll have
chance to use it

</Article>

<Article id="strategyConclusion" title="Conclusion">
So that's it my thoughts on `Strategy Pattern`.
This pattern is a very strong, intelligence, wonderful design pattern. If it was implemented the right way,
it will help us reduce a lots of effort while the changes happen.
Beside of that there is a famous authentication library have used `Strategy Pattern` as their coding strategy.
That is `PassportJS`, you can read it more from [`here`](https://www.passportjs.org/)

</Article>
15:T473c,
<img alt="blockchain-crawler" class="mb-3" src="/blockchain-crawler/bg.webp" />

<p class="mt-3 mb-3">
  Lần này mình sẽ giới thiệu đến các bạn về 1 con crawler event của blockchain
  mà mình tự viết . Các bạn có gì góp ý đóng góp thì cứ tự nhiên để lại comment
  nha
</p>{" "}

  <Article id="blockchainCrawlerOverview" title="Tổng quan">
    
    Trước hết thì mình sẽ nói về cách hoạt động của con crawler. Nó là 1 chương trình nodejs chạy 1 worker interval để crawl theo từng block mới đc thêm vào trên 1 mạng blockchain qua đó thực hiên các action update owner của nft, list nft lên sàn, hay stop listing nft trên sàn. 
  <Article id="blockchainCrawlerDb" class='mt-2' title="Thiết kế database">
  
    Sau đây là sơ đồ tổng quan về database của mình:

    <div class="mt-4">

    <FullSizeImage src={'/blockchain-crawler/db.webp'} vertical className="my-4"/>
    <div class="mt-2">
    - `nft`: Lưu trữ nft

    - `collection`: Lưu collection của nft

    - `loans`: Lưu
    trạng thái và các hành động `lent`,`rent` của nft tương ứng

    - `crawl_process`: Như mình đã nói trên kia ứng dụng của mình sẽ chạy interval worker để xử lý block mới trên 1 contract chỉ  vì vậy bảng này sẽ lưu lại block mới nhất mà đã được process.

    - `queue_logs`: Ứng dụng của mình sẽ không xử lý trực tiếp mà dùng queue pattern để xử lý data. Trước tiên push data nhận đc từ worker bất kì vào bảng queue_log kèm với queue_name tương ứng. Từ đó lấy data từ queue_log ứng và xử lý

    </div>
    </div>

  </Article>

    <Article id="blockchainTech" title="Công nghệ sử dụng">
        - `Typescript`
        - `Nodejs`
        - `Express`
        - `PostgreSQL`
        - `Redis`
        - `Moralis`
        - `bull` (gói quan trọng dùng cho Queue pattern)
        - `web3`
        - `ethers`
        - `typeorm`
    </Article>

    <Article id="blockchainCrawlerBaseClass" title="Các base class trong ứng dụng">
     Dưới đây là các lớp core được sử dụng trong ứng dụng. Mình sẽ chia các lớp có công dụng khác nhau ( chạy tuần tự, launcher,...)
      <Article id="blockchainCrawlerIntervalWorker" title="BaseIntevalWorker">
        - `BaseIntevalWorker` : Một cái "khuôn" để thực hiện 1 action nhất định trong 1 khoảng thời gian. Phương thức `prepare` và `doProcess` sẽ được các lớp kế thừa lớp này viết vào thực hiện action nhất định

    ```ts filename="BaseIntevalWorker.ts" className="my-4"
    export abstract class BaseIntervalWorker {
      private nextTickTime: number = 3000
      private processingTimeout: number = 6000
      private isStopped: boolean = false

      public getProcessingTimeout() {
        return this.processingTimeout
      }

      public getNextTickTime() {
        return this.nextTickTime
      }

      public setNextTickTime(time: number) {
        this.nextTickTime = time
      }

      public setProcessingTimeout(time: number) {
        this.processingTimeout = time
      }
      public stop() {
        this.isStopped = true
      }

      public start(): void {
        this.prepare()
          .then(() => {
            this.onTick()
          })
          .catch(e => {
            console.log(e)
            console.log(`${this.constructor.name} prepare failed`)
          })
      }

      private onTick() {
        if (this.isStopped) {
          return
        }
        const timer = setTimeout(() => {
          console.log(`${this.constructor.name} time out!`)
          process.exit(1)
        }, this.getProcessingTimeout())
        this.doProcess()
          .then(() => {
            if (this.isStopped) return
            clearTimeout(timer)
            setTimeout(() => {
              this.onTick()
            }, this.getNextTickTime())
          })
          .catch(e => {
            console.log(e)
            if (this.isStopped) return
            clearTimeout(timer)
            setTimeout(() => {
              this.onTick()
            }, this.getNextTickTime())
          })
      }

      protected abstract prepare(): Promise<void>
      protected abstract doProcess(): Promise<void>
    }
    ```
      </Article>

      <Article id="blockchainCrawlerEventCrawler" title="BaseEventCrawler">
        - `BaseEventCrawler`: Một lớp base khác được kế thừa từ `BaseIntervalWorker` chịu trách nhiệm đọc những block mới nhất từ đó truyền data đọc được qua phương thức abstract `handleCrawledEvents` từ đó các lớp khác kế thừa lớp này sẽ kế thừa và tùy biến thực hiện action với data crawl được

    ```js filename="BaseEventCrawler.ts" className="my-4"
    import { BaseIntervalWorker } from './BaseIntervalWorker'
    import Web3 from 'web3'
    import dataSource from '../../configs/dataSource'
    import CrawlProcess from '../../entities/CrawlProcess'
    import { Interface, JsonRpcProvider } from 'ethers'
    import { DEFAULT_BREAK_TIME_AFTER_ONE_GO } from '../../common/constant'
    import { NETWORK } from '../../common/enum'
    export interface IEventCrawler {
      networkConfigs: {
        contract: {
          contractName: string
          contractAddress: string
          contractAbi: any
        }

        rpcUrl: string
        network: NETWORK
        blockPerOneGo: number
        averageBlockTime: number
        latestFromNetwork: boolean
        confirmationBlock: number
        latestBlock?: number
      }
    }

    abstract class BaseEventCrawler<R> extends BaseIntervalWorker {
      private LATEST_BLOCK_FROM_NETWORK: number = NaN
      private LATEST_PROCESSED_BLOCK: number = NaN
      private crawlProcess: CrawlProcess
      constructor(protected options: IEventCrawler) {
        super()
      }

      protected abstract handleCrawledEvents(datas: Array<R>): Promise<void>

      protected async processBlock({
        fromBlock,
        toBlock,
        latestNetworkBlock
      }: {
        fromBlock: number
        toBlock: number
        latestNetworkBlock: number
      }) {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        const contract = new web3.eth.Contract(
          this.getContractConfigs().contractAbi,
          this.getContractConfigs().contractAddress
        )
        console.log(
          `Begin process from ${fromBlock} to ${toBlock} / Latest network block: ${latestNetworkBlock}`
        )

        const eventLogs = await contract.getPastEvents(
          'allEvents',
          {
            fromBlock,
            toBlock
          },
          (err: any) => {
            !!err && console.log('Crawl event from sc:', err)
          }
        )
        // console.log("total crawled data:", eventLogs);
        const formattedEventLogs = eventLogs

        await this.handleCrawledEvents(
          formattedEventLogs
            .sort((a, b) => a.blockNumber - b.blockNumber)
            .map(
              event =>
                ({
                  event: event.event,
                  data: event.returnValues,
                  blockNumber: event.blockNumber
                } as R)
            )
        )
      }

      protected getNetworkConfigs() {
        this.getBlockData
        return this.options.networkConfigs
      }
      protected getContractConfigs() {
        return this.options.networkConfigs.contract
      }
      protected getCurLatestProcessedBlock() {
        return parseInt(this.LATEST_PROCESSED_BLOCK.toString(), 10)
      }

      protected async doProcess() {
        if (!this.crawlProcess) {
          console.log(`No crawling process found for : ${this.constructor.name}`)
          return
        }
        const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()

        this.LATEST_BLOCK_FROM_NETWORK = latestBlockFromNetwork

        this.LATEST_PROCESSED_BLOCK = this.crawlProcess.lastProcessedBlock

        let latestProcessedBlock = this.getCurLatestProcessedBlock()

        const fromBlockNumber =
          latestProcessedBlock === 0 ? 0 : latestProcessedBlock + 1

        if (fromBlockNumber > latestBlockFromNetwork) {
          console.log(`Block ${fromBlockNumber} is the newest block`)
          return
        }

        let toBlockNumber = fromBlockNumber + this.getNetworkConfigs().blockPerOneGo
        if (toBlockNumber > latestBlockFromNetwork) {
          console.log('To block is higher')
          toBlockNumber = latestBlockFromNetwork
        }

        console.log(
          `FROM ${fromBlockNumber} TO ${toBlockNumber} LATEST ${latestBlockFromNetwork}`
        )

        await this.processBlock({
          fromBlock: fromBlockNumber,
          toBlock: toBlockNumber,
          latestNetworkBlock: latestBlockFromNetwork
        })

        const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
        this.crawlProcess.lastProcessedBlock = toBlockNumber
        await crawlProcessRepository.save(this.crawlProcess)

        this.LATEST_PROCESSED_BLOCK = toBlockNumber

        // Have processed latest network block so set next tick time by average time
        if (fromBlockNumber === toBlockNumber) {
          this.setNextTickTime(this.getNetworkConfigs().averageBlockTime)
        } else {
          this.setNextTickTime(DEFAULT_BREAK_TIME_AFTER_ONE_GO)
        }
      }

      public async getBlockData(block_number: string | number) {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        return web3.eth.getBlock(block_number)
      }

      public async getTransactionData(block_number: string | number) {
        const jsonProvider = new JsonRpcProvider(this.getNetworkConfigs().rpcUrl)
        const inter = new Interface(this.getContractConfigs().contractAbi)
        const blockData = await this.getBlockData(block_number)

        const datas = await Promise.all(
          blockData.transactions.map(async transaction => {
            const tx = await jsonProvider.getTransaction(transaction)
            if (tx?.data) {
              const decodedOutput = inter.parseTransaction({
                data: tx.data,
                value: tx.value
              })
              return decodedOutput
            }
            return null
          })
        )
        return datas.filter(data => !!data)
      }

      protected async getNetworkLatestBlockNumber() {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        const latestBlockFromNetwork = await web3.eth.getBlockNumber()
        console.log(
          'network',
          latestBlockFromNetwork,
          'real:',
          latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock
        )
        return latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock
      }

      protected async prepare() {
        const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
        const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()

        let crawlerProcess = await crawlProcessRepository
          .createQueryBuilder('CrawlProcess')
          .where({
            contractAddress: this.getContractConfigs().contractAddress
          })
          .andWhere({
            contractName: this.getContractConfigs().contractName
          })
          .getOne()

        if (!crawlerProcess) {
          const newCrawlProcess = new CrawlProcess()
          newCrawlProcess.contractAddress =
            this.getContractConfigs().contractAddress
          newCrawlProcess.contractName = this.getContractConfigs().contractName
          newCrawlProcess.lastProcessedBlock = this.getNetworkConfigs()
            .latestFromNetwork
            ? latestBlockFromNetwork === 0
              ? 0
              : latestBlockFromNetwork - 1
            : (this.getNetworkConfigs().latestBlock || 0) - 1
          try {
            this.crawlProcess = await crawlProcessRepository.save(newCrawlProcess)
          } catch (e: any) {
            console.log(`Error while insert new crawling process: ${e.message}`)
          }
        } else {
          const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
          crawlerProcess.lastProcessedBlock = this.getNetworkConfigs()
            .latestFromNetwork
            ? latestBlockFromNetwork === 0
              ? 0
              : latestBlockFromNetwork - 1
            : (this.getNetworkConfigs().latestBlock || 0) - 1
          await crawlProcessRepository.save(crawlerProcess)

          this.crawlProcess = crawlerProcess
        }
      }
    }

    export default BaseEventCrawler
    ```

        - Các configs số của lớp:
          - `contract`: Thông tin của contract
          - `rpcUrl`: RPC url của mạng
          - `blockPerOneGo`: Thông tin của contract của mạng Số lương block mà 1 lần chạy sẽ lấy (số lượng nên là `200` vì hàm `getPastEvents` của `web3` bị giới hạn số lượng trả về)
          - `averageBlockTime` : Thời gian trung bình để mạng sinh ra 1 block mới
          - `latestFromNetwork`: Nếu option này là `true` thì worker sẽ luôn crawl block mới nhất trên mạng và option `latestBlock` sẽ không có tác dụng
          - `confirmationBlock`: Số lượng block mà mạng cần có để trừ đi với latest block trên mạng để chắc chắn rằng transaction trong 1 block không bị reverse
          - `latestBlock`: Số thứ tự block mà worker sẽ bắt đầu crawl (Nếu `latestFromNetwork` =  `true` thì option này không có tác dụng)

      </Article>

      <Article id="blockchainCrawlerProcessor" title="Processor">
        - `Processor`: Như mình nói ở trên khi các crawler worker crawl được event từ block mới thì sẽ push vào bảng `queue_logs` từ đó lấy data ra và xử lý. Lớp `Processor` được kế thừa từ `BaseIntervalWorker` sẽ làm nhiệm vụ lấy data 1 trong một khoảng thời gian. Lớp con cần kế thừa phương thức `handleUnfinishedOrFailedTask` để xử lý những task được lấy từ databse.

        ```ts filename="Processor.ts" className="my-4"
        import { Queue } from 'bull'
        import { EntityManager } from 'typeorm'
        import QueueManagement from '..'
        import { QUEUE_NAMES } from '../../common/constant'
        import { QueueStatus } from '../../common/enum'
        import { dateInMiliseconds } from '../../common/utils'
        import dataSource from '../../configs/dataSource'
        import QueueLog from '../../entities/QueueLog'
        import { BaseIntervalWorker } from '../../fetcher/base/BaseIntervalWorker'
        import { queueLogRepository } from '../../repository'

        interface IProcessor {
          concurrency?: number
          queue_name: string
        }

        abstract class Processor extends BaseIntervalWorker {
          protected queueInstance: Queue
          protected concurrency: number = 1
          constructor(private queueName: QueueName) {
            super()
            this.queueInstance = QueueManagement.get(this.queueName)!
          }

          public setConcurrency(value: number) {
            this.concurrency = value
          }

          public getConcurrency() {
            return this.concurrency
          }

          protected abstract handleUnfinishedOrFailedTask(
            manager: EntityManager,
            listTask: Array<QueueLog>
          ): Promise<void>

          protected async doProcess(): Promise<void> {
            dataSource.transaction(async (manager: EntityManager) => {
              const listQueueLogs = await manager
                .getRepository(QueueLog)
                .createQueryBuilder('queue_logs')
                .orderBy('retry_at', 'ASC')
                .where(
                  'queue_name = :queue_name AND try_num < 3 AND retry_at < :now AND retry_at IS NOT NULL AND status <> :status',
                  {
                    now: dateInMiliseconds(),
                    status: QueueStatus.COMPLETE,
                    queue_name: this.queueName
                  }
                )
                .take(this.getConcurrency())
                .getMany()

              await this.handleUnfinishedOrFailedTask(manager, listQueueLogs)
            })
          }
        }

        export default Processor
        ```
      </Article>

      <Article id="blockchainLauncher" title="BaseLauncher">
        - Và cuối cùng là lớp `BaseLauncher` dùng để start các worker theo ý của người viết. Các lớp con cần kế thừa phương thức `prepare` và `handleStart` để thực hiện logic.

        ```ts filename="Processor.ts" className="my-4"
          import { wrapperAsync } from '../../common/utils'

          export default abstract class BaseLauncher {
            constructor() {}
            protected abstract prepare(): Promise<void>
            protected abstract handleStart(): Promise<void>
            public async start() {
              const [_, prepareError] = await wrapperAsync(this.prepare())
              if (prepareError) {
                console.log(`${this.constructor.name} cannot prepare`)
                return
              }

              const [startRs, startError] = await wrapperAsync(this.handleStart())

              if (startError) {
                console.log(`${this.constructor.name} running failed`)
                return false
              } else {
                console.log(`${this.constructor.name} running succeed`)
                return true
              }
            }
          }
        ```
      </Article>

    </Article>

  </Article>
<Article id="blockchainCrawlerSummary" class="mt-4" title="Tổng kết">
Như vậy là mình đã giới thiệu cho các bạn về phần 1 về 1 con crawler blockchain rồi. Hẹn các bạn phần sau để implement các lớp base mà hôm nay mình đã giới thiệu các bạn nhé

</Article>
17:{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"}
18:["Tech","Blockchain","Backend","Nodejs","SelfTaught"]
16:{"slug":"voc-vach-code-thu-1-con-crawler-blockchain-phan-1","title":"Vọc vạch code thử 1 crawler event trên mạng blockchain phần 1","date":"04/04/2023","image":"blockchain-crawler/bg.webp","author":"$17","description":"Bài viết hướng dẫn chi tiết về 1 chương trình ví dụ crawler event của blockchain","tags":"$18","isFeature":true,"minutesRead":20}
19:T4cde,
!['tailwindBg'](blockchain-crawler/bg.jpeg)

<p class="mt-3 mb-3">
  Lần này mình sẽ giới thiệu đến các bạn về 1 con crawler event của blockchain
  mà mình tự viết . Các bạn có gì góp ý đóng góp thì cứ tự nhiên để lại comment
  nha
</p>

<div id="blockchainCrawlerMenu">
## [<img src="hashtag.svg" width="20px" height="20px"/>](#blockchainCrawlerMenu) Mục lục

- [Core concepts](#blockchainCrawlerCore)
  - [Tổng quan](#blockchainCrawlerOverview)
    - [Thiết kế database](#blockchainCrawlerDb)
    - [Công nghệ sử dụng](#blockchainTech)
    - [Các base class trong ứng dụng](#blockchainCrawlerBaseClass)
      - [BaseIntevalWorker](#blockchainCrawlerIntervalWorker)
      - [BaseEventCrawler](#blockchainCrawlerEventCrawler)
      - [Processor](#blockchainCrawlerProcessor)
      - [BaseLauncher](#blockchainLauncher)
- [Tổng kết](#blockchainCrawlerSummary)

---

</div>
<div id="blockchainCrawlerCore">
  <article id="blockchainCrawlerOverview">
    ## [<img src="hashtag.svg" width="20px" height="20px" />](#blockchainCrawlerOverview) Tổng quan
    
    Trước hết thì mình sẽ nói về cách hoạt động của con crawler. Nó là 1 chương trình nodejs chạy 1 worker interval để crawl theo từng block mới đc thêm vào trên 1 mạng blockchain qua đó thực hiên các action update owner của nft, list nft lên sàn, hay stop listing nft trên sàn. 
    <article id="blockchainCrawlerDb" class='mt-2'>
    ## [<img src="hashtag.svg" width="20px" height="20px" />](#blockchainCrawlerDb) Thiết kế database
  
    Sau đây là sơ đồ tổng quan về database của mình:

    <div class="mt-4">

    <FullSizeImage src={'/blockchain-crawler/db.png'} />
    <div class="mt-2">
    - `nft`: Lưu trữ nft

    - `collection`: Lưu collection của nft

    - `loans`: Lưu
    trạng thái và các hành động `lent`,`rent` của nft tương ứng

    - `crawl_process`: Như mình đã nói trên kia ứng dụng của mình sẽ chạy interval worker để xử lý block mới trên 1 contract chỉ  vì vậy bảng này sẽ lưu lại block mới nhất mà đã được process.

    - `queue_logs`: Ứng dụng của mình sẽ không xử lý trực tiếp mà dùng queue pattern để xử lý data. Trước tiên push data nhận đc từ worker bất kì vào bảng queue_log kèm với queue_name tương ứng. Từ đó lấy data từ queue_log ứng và xử lý

    </div>
    </div>

    </article>

    <article id="blockchainTech">
      ## [<img src="hashtag.svg" width="20px" height="20px" />](#blockchainTech) Công nghệ sử dụng và các gói quan trọng
        - `Typescript`
        - `Nodejs`
        - `Express`
        - `PostgreSQL`
        - `Redis`
        - `Moralis`
        - `bull` (gói quan trọng dùng cho Queue pattern)
        - `web3`
        - `ethers`
        - `typeorm`
    </article>

    <article id="blockchainCrawlerBaseClass">
      <section id="blockchainCrawlerIntervalWorker">
      ## [<img src="hashtag.svg" width="20px" height="20px" />](#blockchainCrawlerBaseClass) Các base class trong ứng dụng
        <div class="ml-4">
        ### [<img src="hashtag.svg" width="20px" height="20px"/>](#blockchainCrawlerIntervalWorker) BaseIntevalWorker
        </div>
        - `BaseIntevalWorker` : Một cái "khuôn" để thực hiện 1 action nhất định trong 1 khoảng thời gian. Phương thức `prepare` và `doProcess` sẽ được các lớp kế thừa lớp này viết vào thực hiện action nhất định

    ```ts filename="BaseIntevalWorker.ts"
    export abstract class BaseIntervalWorker {
      private nextTickTime: number = 3000
      private processingTimeout: number = 6000
      private isStopped: boolean = false

      public getProcessingTimeout() {
        return this.processingTimeout
      }

      public getNextTickTime() {
        return this.nextTickTime
      }

      public setNextTickTime(time: number) {
        this.nextTickTime = time
      }

      public setProcessingTimeout(time: number) {
        this.processingTimeout = time
      }
      public stop() {
        this.isStopped = true
      }

      public start(): void {
        this.prepare()
          .then(() => {
            this.onTick()
          })
          .catch(e => {
            console.log(e)
            console.log(`${this.constructor.name} prepare failed`)
          })
      }

      private onTick() {
        if (this.isStopped) {
          return
        }
        const timer = setTimeout(() => {
          console.log(`${this.constructor.name} time out!`)
          process.exit(1)
        }, this.getProcessingTimeout())
        this.doProcess()
          .then(() => {
            if (this.isStopped) return
            clearTimeout(timer)
            setTimeout(() => {
              this.onTick()
            }, this.getNextTickTime())
          })
          .catch(e => {
            console.log(e)
            if (this.isStopped) return
            clearTimeout(timer)
            setTimeout(() => {
              this.onTick()
            }, this.getNextTickTime())
          })
      }

      protected abstract prepare(): Promise<void>
      protected abstract doProcess(): Promise<void>
    }
    ```

    <hr class="mb-4 mt-4" />
      </section>

      <section id="blockchainCrawlerEventCrawler">
        <div class="ml-4">
          ### [<img src="hashtag.svg" width="20px" height="20px"/>](#blockchainCrawlerEventCrawler) BaseEventCrawler
        </div>
        - `BaseEventCrawler`: Một lớp base khác được kế thừa từ `BaseIntervalWorker` chịu trách nhiệm đọc những block mới nhất từ đó truyền data đọc được qua phương thức abstract `handleCrawledEvents` từ đó các lớp khác kế thừa lớp này sẽ kế thừa và tùy biến thực hiện action với data crawl được

    ```ts filename="BaseEventCrawler.ts"
    import { BaseIntervalWorker } from './BaseIntervalWorker'
    import Web3 from 'web3'
    import dataSource from '../../configs/dataSource'
    import CrawlProcess from '../../entities/CrawlProcess'
    import { Interface, JsonRpcProvider } from 'ethers'
    import { DEFAULT_BREAK_TIME_AFTER_ONE_GO } from '../../common/constant'
    import { NETWORK } from '../../common/enum'
    export interface IEventCrawler {
      networkConfigs: {
        contract: {
          contractName: string
          contractAddress: string
          contractAbi: any
        }

        rpcUrl: string
        network: NETWORK
        blockPerOneGo: number
        averageBlockTime: number
        latestFromNetwork: boolean
        confirmationBlock: number
        latestBlock?: number
      }
    }

    abstract class BaseEventCrawler<R> extends BaseIntervalWorker {
      private LATEST_BLOCK_FROM_NETWORK: number = NaN
      private LATEST_PROCESSED_BLOCK: number = NaN
      private crawlProcess: CrawlProcess
      constructor(protected options: IEventCrawler) {
        super()
      }

      protected abstract handleCrawledEvents(datas: Array<R>): Promise<void>

      protected async processBlock({
        fromBlock,
        toBlock,
        latestNetworkBlock
      }: {
        fromBlock: number
        toBlock: number
        latestNetworkBlock: number
      }) {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        const contract = new web3.eth.Contract(
          this.getContractConfigs().contractAbi,
          this.getContractConfigs().contractAddress
        )
        console.log(
          `Begin process from ${fromBlock} to ${toBlock} / Latest network block: ${latestNetworkBlock}`
        )

        const eventLogs = await contract.getPastEvents(
          'allEvents',
          {
            fromBlock,
            toBlock
          },
          (err: any) => {
            !!err && console.log('Crawl event from sc:', err)
          }
        )
        // console.log("total crawled data:", eventLogs);
        const formattedEventLogs = eventLogs

        await this.handleCrawledEvents(
          formattedEventLogs
            .sort((a, b) => a.blockNumber - b.blockNumber)
            .map(
              event =>
                ({
                  event: event.event,
                  data: event.returnValues,
                  blockNumber: event.blockNumber
                } as R)
            )
        )
      }

      protected getNetworkConfigs() {
        this.getBlockData
        return this.options.networkConfigs
      }
      protected getContractConfigs() {
        return this.options.networkConfigs.contract
      }
      protected getCurLatestProcessedBlock() {
        return parseInt(this.LATEST_PROCESSED_BLOCK.toString(), 10)
      }

      protected async doProcess() {
        if (!this.crawlProcess) {
          console.log(`No crawling process found for : ${this.constructor.name}`)
          return
        }
        const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()

        this.LATEST_BLOCK_FROM_NETWORK = latestBlockFromNetwork

        this.LATEST_PROCESSED_BLOCK = this.crawlProcess.lastProcessedBlock

        let latestProcessedBlock = this.getCurLatestProcessedBlock()

        const fromBlockNumber =
          latestProcessedBlock === 0 ? 0 : latestProcessedBlock + 1

        if (fromBlockNumber > latestBlockFromNetwork) {
          console.log(`Block ${fromBlockNumber} is the newest block`)
          return
        }

        let toBlockNumber = fromBlockNumber + this.getNetworkConfigs().blockPerOneGo
        if (toBlockNumber > latestBlockFromNetwork) {
          console.log('To block is higher')
          toBlockNumber = latestBlockFromNetwork
        }

        console.log(
          `FROM ${fromBlockNumber} TO ${toBlockNumber} LATEST ${latestBlockFromNetwork}`
        )

        await this.processBlock({
          fromBlock: fromBlockNumber,
          toBlock: toBlockNumber,
          latestNetworkBlock: latestBlockFromNetwork
        })

        const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
        this.crawlProcess.lastProcessedBlock = toBlockNumber
        await crawlProcessRepository.save(this.crawlProcess)

        this.LATEST_PROCESSED_BLOCK = toBlockNumber

        // Have processed latest network block so set next tick time by average time
        if (fromBlockNumber === toBlockNumber) {
          this.setNextTickTime(this.getNetworkConfigs().averageBlockTime)
        } else {
          this.setNextTickTime(DEFAULT_BREAK_TIME_AFTER_ONE_GO)
        }
      }

      public async getBlockData(block_number: string | number) {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        return web3.eth.getBlock(block_number)
      }

      public async getTransactionData(block_number: string | number) {
        const jsonProvider = new JsonRpcProvider(this.getNetworkConfigs().rpcUrl)
        const inter = new Interface(this.getContractConfigs().contractAbi)
        const blockData = await this.getBlockData(block_number)

        const datas = await Promise.all(
          blockData.transactions.map(async transaction => {
            const tx = await jsonProvider.getTransaction(transaction)
            if (tx?.data) {
              const decodedOutput = inter.parseTransaction({
                data: tx.data,
                value: tx.value
              })
              return decodedOutput
            }
            return null
          })
        )
        return datas.filter(data => !!data)
      }

      protected async getNetworkLatestBlockNumber() {
        const web3 = new Web3(this.getNetworkConfigs().rpcUrl)
        const latestBlockFromNetwork = await web3.eth.getBlockNumber()
        console.log(
          'network',
          latestBlockFromNetwork,
          'real:',
          latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock
        )
        return latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock
      }

      protected async prepare() {
        const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
        const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()

        let crawlerProcess = await crawlProcessRepository
          .createQueryBuilder('CrawlProcess')
          .where({
            contractAddress: this.getContractConfigs().contractAddress
          })
          .andWhere({
            contractName: this.getContractConfigs().contractName
          })
          .getOne()

        if (!crawlerProcess) {
          const newCrawlProcess = new CrawlProcess()
          newCrawlProcess.contractAddress =
            this.getContractConfigs().contractAddress
          newCrawlProcess.contractName = this.getContractConfigs().contractName
          newCrawlProcess.lastProcessedBlock = this.getNetworkConfigs()
            .latestFromNetwork
            ? latestBlockFromNetwork === 0
              ? 0
              : latestBlockFromNetwork - 1
            : (this.getNetworkConfigs().latestBlock || 0) - 1
          try {
            this.crawlProcess = await crawlProcessRepository.save(newCrawlProcess)
          } catch (e: any) {
            console.log(`Error while insert new crawling process: ${e.message}`)
          }
        } else {
          const crawlProcessRepository = dataSource.getRepository(CrawlProcess)
          crawlerProcess.lastProcessedBlock = this.getNetworkConfigs()
            .latestFromNetwork
            ? latestBlockFromNetwork === 0
              ? 0
              : latestBlockFromNetwork - 1
            : (this.getNetworkConfigs().latestBlock || 0) - 1
          await crawlProcessRepository.save(crawlerProcess)

          this.crawlProcess = crawlerProcess
        }
      }
    }

    export default BaseEventCrawler
    ```

        - Các configs số của lớp:
          - `contract`: Thông tin của contract
          - `rpcUrl`: RPC url của mạng
          - `blockPerOneGo`: Thông tin của contract của mạng Số lương block mà 1 lần chạy sẽ lấy (số lượng nên là `200` vì hàm `getPastEvents` của `web3` bị giới hạn số lượng trả về)
          - `averageBlockTime` : Thời gian trung bình để mạng sinh ra 1 block mới
          - `latestFromNetwork`: Nếu option này là `true` thì worker sẽ luôn crawl block mới nhất trên mạng và option `latestBlock` sẽ không có tác dụng
          - `confirmationBlock`: Số lượng block mà mạng cần có để trừ đi với latest block trên mạng để chắc chắn rằng transaction trong 1 block không bị reverse
          - `latestBlock`: Số thứ tự block mà worker sẽ bắt đầu crawl (Nếu `latestFromNetwork` =  `true` thì option này không có tác dụng)

    <hr class="mb-4 mt-4" />

      </section>

      <section id="blockchainCrawlerProcessor">
        <div class="ml-4">
          ### [<img src="hashtag.svg" width="20px" height="20px"/>](#blockchainCrawlerProcessor) Processor
        </div>
        - `Processor`: Như mình nói ở trên khi các crawler worker crawl được event từ block mới thì sẽ push vào bảng `queue_logs` từ đó lấy data ra và xử lý. Lớp `Processor` được kế thừa từ `BaseIntervalWorker` sẽ làm nhiệm vụ lấy data 1 trong một khoảng thời gian. Lớp con cần kế thừa phương thức `handleUnfinishedOrFailedTask` để xử lý những task được lấy từ databse.

        ```ts filename="Processor.ts"
        import { Queue } from 'bull'
        import { EntityManager } from 'typeorm'
        import QueueManagement from '..'
        import { QUEUE_NAMES } from '../../common/constant'
        import { QueueStatus } from '../../common/enum'
        import { dateInMiliseconds } from '../../common/utils'
        import dataSource from '../../configs/dataSource'
        import QueueLog from '../../entities/QueueLog'
        import { BaseIntervalWorker } from '../../fetcher/base/BaseIntervalWorker'
        import { queueLogRepository } from '../../repository'

        interface IProcessor {
          concurrency?: number
          queue_name: string
        }

        abstract class Processor extends BaseIntervalWorker {
          protected queueInstance: Queue
          protected concurrency: number = 1
          constructor(private queueName: QueueName) {
            super()
            this.queueInstance = QueueManagement.get(this.queueName)!
          }

          public setConcurrency(value: number) {
            this.concurrency = value
          }

          public getConcurrency() {
            return this.concurrency
          }

          protected abstract handleUnfinishedOrFailedTask(
            manager: EntityManager,
            listTask: Array<QueueLog>
          ): Promise<void>

          protected async doProcess(): Promise<void> {
            dataSource.transaction(async (manager: EntityManager) => {
              const listQueueLogs = await manager
                .getRepository(QueueLog)
                .createQueryBuilder('queue_logs')
                .orderBy('retry_at', 'ASC')
                .where(
                  'queue_name = :queue_name AND try_num < 3 AND retry_at < :now AND retry_at IS NOT NULL AND status <> :status',
                  {
                    now: dateInMiliseconds(),
                    status: QueueStatus.COMPLETE,
                    queue_name: this.queueName
                  }
                )
                .take(this.getConcurrency())
                .getMany()

              await this.handleUnfinishedOrFailedTask(manager, listQueueLogs)
            })
          }
        }

        export default Processor
        ```

        <hr class="mb-4 mt-4" />
      </section>

      <section id="blockchainLauncher">
        <div class="ml-4">
          ### [<img src="hashtag.svg" width="20px" height="20px"/>](#blockchainLauncher) BaseLauncher
        </div>

        - Và cuối cùng là lớp `BaseLauncher` dùng để start các worker theo ý của người viết. Các lớp con cần kế thừa phương thức `prepare` và `handleStart` để thực hiện logic.

        ```ts filename="Processor.ts"
          import { wrapperAsync } from '../../common/utils'

          export default abstract class BaseLauncher {
            constructor() {}
            protected abstract prepare(): Promise<void>
            protected abstract handleStart(): Promise<void>
            public async start() {
              const [_, prepareError] = await wrapperAsync(this.prepare())
              if (prepareError) {
                console.log(`${this.constructor.name} cannot prepare`)
                return
              }

              const [startRs, startError] = await wrapperAsync(this.handleStart())

              if (startError) {
                console.log(`${this.constructor.name} running failed`)
                return false
              } else {
                console.log(`${this.constructor.name} running succeed`)
                return true
              }
            }
          }
        ```

        ---
      </section>

    </article>

  </article>
</div>

<div id="blockchainCrawlerSummary" class="mt-4">
## [<img src="hashtag.svg" width="20px" height="20px" />](#blockchainCrawlerSummary) Tổng kết

Như vậy là mình đã giới thiệu cho các bạn về phần 1 về 1 con crawler blockchain rồi. Hẹn các bạn phần sau để implement các lớp base mà hôm nay mình đã giới thiệu các bạn nhé

</div>
1a:T187b,
Hello guys, in this article we will explore something really interesting called `Event Bus`. I will give you a briefly overview
and provide you with some exciting code examples in both frontend and backend side to help you understand it clearly.
So let get right into it.

<div className="my-3">

!['bus'](/what-is-event-bus/bus.webp)

</div>

<Article id="whatIsEventBus" title="What is Event Bus">
  An event bus is a router that receives events and delivers them to zero or
  more destinations,or targets. Use an event bus when you need to route events
  from many sources to many targets, with optional transformation of events
  prior to delivery to a target.
</Article>

<Article id="sampleFe" title="Sample example for FE">
 - Browser have an interesting method `addEventListener` and `dispatchEvent`. You can use it directly using `window` object
 - <div className="mt-2"></div>
 - So I will use it to implement `EventBus` function
{/* - So let get into an example of `Event Bus` for Frontend side */}

```ts filename="event-bus.ts" className="my-4"
type ListenerFunc = (e: CustomEvent) => void;

const handlers: Record<string, Array<ListenerFunc>> = {};

const EventBus = {
  on(eventName: string, listener: ListenerFunc) {
    handlers[eventName] = handlers[eventName]
      ? [...handlers[eventName], listener]
      : [listener];
    window.addEventListener(eventName, listener as any);
  },

  once(eventName: string, listener: ListenerFunc) {
    handlers[eventName] = handlers[eventName]
      ? [...handlers[eventName], listener]
      : [listener];

    window.addEventListener(eventName, listener as any, {
      once: true,
    });
  },

  removeAllListeners(eventName: string) {
    const listeners = handlers[eventName] || [];
    listeners.forEach((listener) => {
      window.removeEventListener(eventName, listener as any);
    });
    delete handlers[eventName];
  },

  emit(eventName: string, data: any) {
    window.dispatchEvent(
      new CustomEvent(eventName, {
        detail: data,
      })
    );
  },

  off(eventName: string, listener: ListenerFunc) {
    const listeners = handlers[eventName] || [];

    const listenerIndex = listeners.findIndex((listen) => {
      return listener === listen;
    });

    if (listenerIndex !== -1) {
      listeners.splice(listenerIndex, 1);
      window.removeEventListener(eventName, listener as any);
    }
  },
};

export default EventBus;
```

You can use it like this 👇

```tsx filename="EventBus.tsx" className="mt-4 mb-8 lg:mb-12"
import EventBus from "@/utils/eventBus";

useEffect(() => {
  const listener = (e: CustomEvent) => {
    console.log("Event receive", e.detail);
  };
  EventBus.on("sayHello", listener);

  return () => {
    EventBus.off("sayHello", listener);
  };
}, []);

return (
  <>
    <button
      onClick={() => {
        EventBus.emit("sayHello", { msg: "Hello world!" });
      }}
    >
      Emit say hello
    </button>
  </>
);
```

<Quote title={"Be careful!"} type={"DANGER"}>
  - At `off` method you must pass as same as the listener function which you
  have passed to when using `on` method. If you pass the wrong one => the event
  won't be cleared
</Quote>

</Article>

<Article id="sampleBe" title="Sample example for BE">
  - Nodejs have built-in class
  [`EventEmitter`](https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter).
  Hence , we don't need to implement it from scratch. So I will code an example
  to use it.

```ts filename="index.ts" className="mt-4 mb-8 lg:mb-12"
import EventEmitter from "node:events";

interface AnyObject {
  [key: string]: any;
}

interface EmitPayload extends AnyObject {
  eventName: string;
  userId?: string;
}

const handleCreateGoal = async (payload: EmitPayload) => {
  try {
    const { eventName, ...metrics } = payload;
    // Do something with eventName and metrics here
  } catch (e) {
    console.log("Create goal failed:", e);
  }
};

const handleCreateGoalExclusive = async (payload: EmitPayload) => {
  try {
    const { eventName, ...metrics } = payload;
    // Firstly check event with this user exist or not => call add function when that event with user not exist

    // Do something with eventName and metrics here
  } catch (e) {
    console.log("Create goal exclusive failed:", e);
  }
};

class ThirdPartyTracking {
  static eventEmitter: EventEmitter;
  constructor() {
    if (ThirdPartyTracking.eventEmitter) {
      ThirdPartyTracking.eventEmitter.off("CREATE_GOAL", handleCreateGoal);
      ThirdPartyTracking.eventEmitter.on("CREATE_GOAL", handleCreateGoal);
      ThirdPartyTracking.eventEmitter.off(
        "CREATE_GOAL_EXCLUSIVE",
        handleCreateGoalExclusive
      );
      ThirdPartyTracking.eventEmitter.on(
        "CREATE_GOAL_EXCLUSIVE",
        handleCreateGoalExclusive
      );
      return this;
    }
    ThirdPartyTracking.eventEmitter = new EventEmitter();
    ThirdPartyTracking.eventEmitter.on("CREATE_GOAL", handleCreateGoal);
    ThirdPartyTracking.eventEmitter.on(
      "CREATE_GOAL_EXCLUSIVE",
      handleCreateGoalExclusive
    );
  }

  static emit(payload: EmitPayload) {
    ThirdPartyTracking.eventEmitter.emit("CREATE_GOAL", payload);
  }

  static emitCreateExclusive(payload: EmitPayload) {
    ThirdPartyTracking.eventEmitter.emit("CREATE_GOAL_EXCLUSIVE", payload);
  }
}

// Initialize
new ThirdPartyTracking();

// Call our service
ThirdPartyTracking.emitCreateExclusive({
  eventName: "hello world exclusive",
  userId: "1",
});

ThirdPartyTracking.emit({
  eventName: "hello world",
  userId: "2",
});
```

<Quote title={"Caution"} type={"WARNING"}>
  - We should seperate our `EventBus` listener logic into another module.
  Because when we code like this, our listener's code will be run on the same
  process as other code => This is not a reasonable implementation. So will
  should only place our message broker's interaction code in that listener or
  maybe a [`Nodejs's Child Process`](https://nodejs.org/api/child_process.html)
</Quote>

</Article>

<Article id="eventBusConclusion" title="Conclusion">
  Well, that's all for now, folks! `EventBus` for me is a very strong indeed.
  When you use it right, it can seperate your service's logic without waiting
  for other's logic to be completed.
</Article>
7:["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__className_608eb6 bg-primary dark:bg-dark-primary overflow-x-hidden","children":["$","$Ld",null,{"children":["$","$Le",null,{"posts":[{"id":"cac-extension-minh-dung-trong-vs-code","metadata":{"slug":"cac-extension-minh-dung-trong-vs-code","title":"Các extension xịn xò mà mình dùng trong Visual Studio Code","date":"10/13/2022","image":"vs_code.png","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Bạn là một developer và bạn dùng Visual Studio Code. Visual Studio Code là 1 text editor khá mới nhưng free, chạy được trên nhiều hệ điều hành. Tuy chỉ là text editor nhưng ta vẫn có thể compile, run, debug code trên VS Code, không thua gì cái IDE xịn. Vừa nhẹ, vừa free, lại mạnh mẽ, nên dân web developer như mình rất khoái dùng VS Code. Sau đây mình sẽ giới thiệu cho các bạn những extension xịn xò nhen","tags":["Tech","IDE","Tool","Extension"],"isFeature":false,"minutesRead":5},"content":"$f"},{"id":"cach-dung-tailwind-css-phan-1","metadata":{"slug":"cach-dung-tailwind-css-phan-1","title":"Giới thiệu các directives đặc biệt và cách dùng TailwindCSS (phần 1)","date":"10/10/2022","image":"cach-dung-tailwind/tailwindBg.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Chào các bạn qua bài trước chắc hẳn các bạn đã có thể cài đặt TailwindCSS cho dự án của mình rồi nếu các bạn bỏ lỡ thì nó ở đây.Hôm nay chúng ta tiếp tục với việc tìm hiểu TailwindCSS qua các ví dụ.","tags":["News","Tech","Tailwind CSS","Frontend"],"isFeature":false,"minutesRead":10},"content":"$10"},{"id":"cai-dat-tailwind-css","metadata":{"slug":"cai-dat-tailwind-css","title":"Tìm hiểu về Tailwind CSS và cài đặt cho dự án React","date":"10/09/2022","image":"blockchain-crawler/bg.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Bạn đang lo lắng vì đặt tên class, sợ bị trùng css không mong muốn,hay đang muốn một framework giống bootstrap để tận dụng được các class dùng chung mà không viết lại quá nhiều. TailwindCSS là framework dành cho bạn","tags":["News","Tech","Tailwind CSS","Frontend"],"isFeature":false,"minutesRead":10},"content":"$11"},{"id":"factory-design-pattern","metadata":{"slug":"factory-design-pattern","title":"Factory Design Pattern","date":"16-07-2024","image":"design-patterns/factory.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Hello folks, today I would like to introduce to you Factory Design Pattern","tags":["Tech","Javascript","Design Pattern"],"isFeature":false,"minutesRead":10},"content":"\n<div className=\"my-4\">!['factory'](/design-patterns/factory.webp)</div>\n"},{"id":"how-i-build-this-blog","metadata":{"slug":"how-i-build-this-blog","title":"How I build this blog 🚀","date":"07-07-2024","image":"how-i-build-this-blog/main.jpeg","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"I want to share my personal's blog coding journey. How was it made. What kind of technology I'm using","tags":["Tech","Javascript","Frontend","Tailwind CSS"],"isFeature":true,"minutesRead":15},"content":"$12"},{"id":"javascript-utility-function-1","metadata":{"slug":"javascript-utility-function-1","title":"My personal Javascript's utility functions, part 1","date":"15-07-2024","image":"javascript.jpeg","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"I want to share my personal's blog coding journey. How was it made. What kind of technology I'm using","tags":["Tech","Javascript"],"isFeature":false,"minutesRead":5},"content":"$13"},{"id":"strategy-design-pattern","metadata":{"slug":"strategy-design-pattern","title":"Strategy Design Pattern","date":"15-07-2024","image":"design-patterns/strategy.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Hello folks, today I would like to introduce to you Strategy Design Pattern","tags":["Tech","Javascript","Design Pattern"],"isFeature":false,"minutesRead":11},"content":"$14"},{"id":"voc-vach-code-thu-1-con-crawler-blockchain-phan-2","metadata":{"slug":"voc-vach-code-thu-1-con-crawler-blockchain-phan-2","title":"Vọc vạch code thử 1 crawler event trên mạng blockchain phần 2","date":"07/04/2023","image":"blockchain-crawler/bg.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Phần tiếp theo của chuỗi bài viết vọc vạch tự làm 1 con blockchain event crawler","tags":["Tech","Blockchain","Backend","Nodejs","SelfTaught"],"isFeature":true,"minutesRead":20},"content":"$15"},{"id":"voc-vach-code-thu-1-con-crawler-blockchain","metadata":"$16","content":"$19"},{"id":"what-is-event-bus","metadata":{"slug":"what-is-event-bus","title":"What is event bus in javascript ? How to use it","date":"14-08-2024","image":"what-is-event-bus/bus.webp","author":{"name":"Đức Huy Hoàng","avatar":"avatar.jpg"},"description":"Hello guys, in this article we will explore something really interesting called `Event Bus`. I will give you a briefly overview and provide you with some exciting code examples in both frontend and backend side to help you understand it clearly. So let get right into it.","tags":["Tech","Javascript"],"isFeature":false,"minutesRead":12},"content":"$1a"}],"children":["$","$L1b",null,{"children":["$","$L1c",null,{"children":[["$","$L1d",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","section",null,{"className":"flex flex-col justify-center items-center h-[100dvh] w-full","children":[["$","div",null,{"className":"main_wrapper","children":[["$","div",null,{"className":"main","children":[["$","div",null,{"className":"antenna","children":[["$","div",null,{"className":"antenna_shadow"}],["$","div",null,{"className":"a1"}],["$","div",null,{"className":"a1d"}],["$","div",null,{"className":"a2"}],["$","div",null,{"className":"a2d"}],["$","div",null,{"className":"a_base"}]]}],["$","div",null,{"className":"tv","children":[["$","div",null,{"className":"cruve"}],["$","div",null,{"className":"display_div","children":["$","div",null,{"className":"screen_out","children":["$","div",null,{"className":"screen_out1","children":["$","div",null,{"className":"screen","children":["$","span",null,{"className":"notfound_text fa","children":" NOT FOUND"}]}]}]}]}],["$","div",null,{"className":"lines","children":[["$","div",null,{"className":"line1"}],["$","div",null,{"className":"line2"}],["$","div",null,{"className":"line3"}]]}],["$","div",null,{"className":"buttons_div","children":[["$","div",null,{"className":"b1","children":["$","div",null,{}]}],["$","div",null,{"className":"b2"}],["$","div",null,{"className":"speakers","children":[["$","div",null,{"className":"g1","children":[["$","div",null,{"className":"g11"}],["$","div",null,{"className":"g12"}],["$","div",null,{"className":"g13"}]]}],["$","div",null,{"className":"g"}],["$","div",null,{"className":"g"}]]}]]}]]}],["$","div",null,{"className":"bottom","children":[["$","div",null,{"className":"base1"}],["$","div",null,{"className":"base2"}],["$","div",null,{"className":"base3"}]]}]]}],["$","div",null,{"className":"text_404","children":[["$","div",null,{"className":"text_4041","children":"4"}],["$","div",null,{"className":"text_4042","children":"0"}],["$","div",null,{"className":"text_4043","children":"4"}]]}]]}],["$","$L1e",null,{"href":"/","children":["$","button",null,{"className":"flex items-center mt-12 bg-[#171e22] min-w-[68px] py-[11px] px-[16px] rounded font-semibold text-[1.125rem] w-max hover:opacity-80","children":[["$","svg",null,{"stroke":"currentColor","fill":"currentColor","strokeWidth":"0","viewBox":"0 0 576 512","className":"size-[20px] !text-white ","children":["$undefined",[["$","path","0",{"d":"M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z","children":[]}]]],"style":{"color":"$undefined"},"height":"1em","width":"1em","xmlns":"http://www.w3.org/2000/svg"}],["$","p",null,{"className":"text-text-color dark:text-text-color-dark antialiased !text-white font-bold ml-4","children":"Home"}]]}]}]]}],"notFoundStyles":[["$","link","0",{"rel":"stylesheet","href":"/duc-huy-hoang-blog-v2/_next/static/css/718dced7f5913455.css","precedence":"next","crossOrigin":"$undefined"}]],"styles":[["$","link","0",{"rel":"stylesheet","href":"/duc-huy-hoang-blog-v2/_next/static/css/384966b44c8cd115.css","precedence":"next","crossOrigin":"$undefined"}]]}]}],["$","$L1f",null,{}]]}]}]}]}]}]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","link","2",{"rel":"icon","href":"/duc-huy-hoang-blog-v2/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","3",{"name":"next-size-adjust"}]]
1:null
